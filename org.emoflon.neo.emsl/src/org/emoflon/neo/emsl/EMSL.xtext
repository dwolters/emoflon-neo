grammar org.emoflon.neo.emsl.EMSL with org.eclipse.xtext.common.Terminals

generate eMSL "http://www.emoflon.org/neo/emsl/EMSL"

EMSL_Spec:
	imports+=ImportStatement* entities+=Entity+
;

ImportStatement:
	'import' value=STRING ('as' alias=ID)?
;

Entity:
	Metamodel | Model | Pattern | Rule | Constraint | TripleRule | TripleGrammar | GraphGrammar | Enum
;

Metamodel:
	'metamodel' name=QualifiedName '{' nodeBlocks+=MetamodelNodeBlock* '}'
;

Model:
	'model' name=QualifiedName '{' nodeBlocks+=NodeBlock* '}'
;

Pattern:
	'pattern' name=QualifiedName 
	('->' (superTypes+=[SuperType|QualifiedName] ('['  ']')? (',' superTypes+=[SuperType|QualifiedName] ('['  ']')?)*))? // TODO [Maximilian]: fill relabeling brackets
	'{'
	 	nodeBlocks+=NodeBlock* 
	'}' ('when' conditions+=TypeReference (('&&' | '||') conditions+=(TypeReference))*
	)?
;

Rule:
	(abstract?='abstract')? 'rule' name=QualifiedName 
	('->' (superTypes+=[SuperType|QualifiedName] ('['  ']')? (',' superTypes+=[SuperType|QualifiedName] ('[' ']')? )*))? // TODO [Maximilian]: fill relabeling brackets
	'{' 
		nodeBlocks+=NodeBlock* 
	'}' ('when' conditions+=(TypeReference) (('&&' | '||') conditions+=(TypeReference))*
	)?
;

TripleRule:
	(abstract?='abstract')? 'tripleRule' name=QualifiedName 
	(':' grammarType=[TripleGrammar|QualifiedName])? ('->' superTypes+=[SuperType|QualifiedName] (',' superTypes+=[SuperType|QualifiedName])*)?
	('{' 
		('source' '{' srcNodeBlocks+=NodeBlock* '}')?
		('target' '{' trgNodeBlocks+=NodeBlock* '}')?
		('correspondence' '{' correspondences+=TripleRuleCorrespondence+ '}')?
		('attributeConditions' '{' 
			(attributeConditions+=AttributeCondition)*
		'}')?
	 '}')? ('when' conditionOperator='forbid' nacs+=TripleRuleNACs (',' nacs+=TripleRuleNACs)*)?
;

TripleRuleCorrespondence:
	((action=Action)? source=[NodeBlock|QualifiedName] '<-' ':' type=[Correspondence|QualifiedName] '->' target=[NodeBlock|QualifiedName])
;

AttributeCondition:
	operator+=AttributeConditionAction '(' (operands+=[PropertyStatement|QualifiedName]|constant+=INT) ((',') (operands+=[PropertyStatement|QualifiedName]|constant+=INT))* ')'
;

AttributeConditionAction:
	op=AttributeConditionOperator
;

TripleRuleNACs:
	pattern=[TypeReference|QualifiedName] | (location=('source'|'target') '(' pattern=[TypeReference|QualifiedName] ')' )
;

Correspondence:
	source+=[MetamodelNodeBlock|QualifiedName] '<-' name=QualifiedName '->' target+=[MetamodelNodeBlock|QualifiedName]
;

TripleGrammar:
	'tripleGrammar' name=QualifiedName '{'
		'source' '{' srcMetamodels+=[Metamodel|QualifiedName]* '}'
		'target' '{' trgMetamodels+=[Metamodel|QualifiedName]* '}'
		'correspondence' '{' correspondences+=Correspondence* '}'
		'attributeConditions' '{'  '}' // TODO [Maximilian]: fill
	'}'
;

GraphGrammar:
	'graphGrammar' name=QualifiedName '{'
		rules+=[Rule|QualifiedName]*
	'}'
;

Enum:
	'enum' name=QualifiedName '{'
		enumItems+=EnumElement*
	'}'
;

EnumElement:
	name = ID
;

NodeBlock:
	(abstract?='abstract')? (action=Action)? name=ID ':' type=[MetamodelNodeBlock|QualifiedName]
	('->' (superTypes+=[NodeBlock|QualifiedName] (',' superTypes+=[NodeBlock|QualifiedName])*))?
	('{'
		(propertyStatements+=PropertyStatement | relationStatements+=RelationStatement | conditionStatements+=ConditionStatement)*
	'}')?
;

PropertyStatement:
	'.' propertyName=[MetamodelPropertyStatement|ID] ':' value=PropertyValue
;

RelationStatement:
	(action=Action)? '-' relationName=[MetamodelRelationStatement|QualifiedName] '->' value=[NodeBlock|QualifiedName] ('{' propertyStatements+=PropertyStatement* '}')?
;

MetamodelNodeBlock:
	(abstract?='abstract')? name=ID ':' type=[MetamodelNodeBlock|QualifiedName]
	('->' (superTypes+=[MetamodelNodeBlock|QualifiedName] (',' superTypes+=[MetamodelNodeBlock|QualifiedName])*))?
	('{'
		(metamodelPropertyStatements+=MetamodelPropertyStatement | metamodelRelationStatements+=MetamodelRelationStatement)*
	'}')?
;

MetamodelPropertyStatement:
	'.' name=ID ':' value=[EnumElement|QualifiedName]
;

MetamodelRelationStatement:
	(action=Action)? relationType=RelationType name=ID '->' ('[' constantLowerBound=MultiplicityValue ('..' upperBound=MultiplicityValue)? ']')? value=[MetamodelNodeBlock|QualifiedName] ('{' propertyStatements+=MetamodelPropertyStatement* '}')?
;

ConditionStatement:
	'.' name=ID op=NodeBlockConditionOperator value=PropertyValue
;

Constraint:
	'constraint' name=QualifiedName '=' constraints+=TypeReference (('&&' | '||') constraints+=TypeReference)*
;

// types a Pattern/Rule can refine; maybe add NodeBlock and TripleRule?
SuperType:
	Metamodel | Model | Pattern | Rule | TripleRule
;

// split between atomic condition and constraint (needed to fix syntax)
TypeReference:
	ConditionTypes | (operator?='!')? constraints+=[Constraint|QualifiedName]
;

ConditionTypes:
	NegativeConstraintBody | PositiveConstraintBody | ImplicationBody
;
	
NegativeConstraintBody:
	conditionOperator='forbid' pattern=[Pattern|QualifiedName]
;
	
PositiveConstraintBody:
	conditionOperator='enforce' pattern=[Pattern|QualifiedName]
;
	
ImplicationBody:
	conditionOperator='if' premise=[Pattern|QualifiedName] 'then' conclusion=[Pattern|QualifiedName]
; 

PropertyValue:
	INT | ID
;

MultiplicityValue:
	INT | ID | "*"
;

QualifiedName:
	ID ('.' ID)*
;

Action:
	op=Operator
;

enum Operator:
	CREATE='++' | DELETE='--'
;
	
enum RelationType:
	REFERENCE='-' | AGGREGATION='<>' | KOMPOSITION='<+>'
;	

enum NodeBlockConditionOperator:
	NOTEQ='!=' | LESS='<' | LESSEQ='<=' | EQ='==' | GREATER='>' | GREATEREQ='>='
;
	
enum AttributeConditionOperator:
	ADD='add' | ADDPREFIX='addPrefix' | ADDSUFFIX='addSuffix' | CONCAT='concat' | DIVIDE='divide' | EQBOOLEAN='eq_boolean' | EQCHAR='eq_char' |
	EQDOUBLE='eq_double' | EQFLOAT='eq_float' | EQINT='eq_int' | EQLONG='eq_long' | EQSTRING='eq_string' | MAX='max' | MULTIPLY='multiply' |
	SETDEFAULTNumber='setDefaultNumber' | SETDEFAULTSTRING='setDefaultString' | SETRANDOMSTRING='setRandomString' | SMALLEROREQUAL='smallerOrEqual' |
	STRINGTODOUBLE='stringToDouble' | STRINGTOINT='stringToInt' | SUB='sub'
;
