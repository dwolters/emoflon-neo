grammar org.emoflon.neo.emsl.EMSL with org.eclipse.xtext.common.Terminals

generate eMSL "http://www.emoflon.org/neo/emsl/EMSL"

EMSL_Spec:
	imports+=ImportStatement* entities+=Entity+;

ImportStatement:
	'import' value=STRING ('as' alias=ID)?;

Entity:
	Metamodel | Model | Pattern | Rule | Constraint | TripleRule;

Metamodel:
	'metamodel' name=QualifiedName '{' nodeBlocks+=NodeBlock* '}';

Model:
	'model' name=QualifiedName '{' nodeBlocks+=NodeBlock* '}';

Pattern:
	'pattern' name=QualifiedName 
	('->' (superTypes+=[SuperTypes|QualifiedName] ('['  ']')? (',' superTypes+=[SuperTypes|QualifiedName] ('['  ']')?)*))? // TODO: fill relabeling brackets
	'{'
	 	nodeBlocks+=NodeBlock* 
	 '}' ('when' conditions+=TypeReference 
	 	(('&&' | '||') conditions+=(TypeReference))*
	 )?;

Rule:
	(abstract?='abstract')? 'rule' name=QualifiedName 
	('->' (superTypes+=[SuperTypes|QualifiedName] ('['  ']')? (',' superTypes+=[SuperTypes|QualifiedName] ('[' ']')? )*))? // TODO: fill relabeling brackets
	'{' nodeBlocks+=NodeBlock* '}' ('when' conditions+=(TypeReference) 
	 	(('&&' | '||') conditions+=(TypeReference))*
	 )?;

TripleRule:
	(abstract?='abstract')? 'tripleRule' name=QualifiedName 
	('->' (superTypes+=[NodeBlock|QualifiedName] (',' superTypes+=[NodeBlock|QualifiedName]*)?))?
	'{' 
		'source' '{' nodeBlocks+=NodeBlock* '}'
		'target' '{' nodeBlocks+=NodeBlock* '}'
		'correspondence' '{' (action+=Action corrName+=QualifiedName '{' (src+=QualifiedName '<->' trg+=QualifiedName) '}')+ '}'
		'attributeCondition' '{'  '}' //TODO: fill attr condi block
	 '}'
;

NodeBlock:
	(abstract?='abstract')? (action=Action)? name=ID ':' type=[NodeBlock|QualifiedName]
	('->' (superTypes+=[NodeBlock|QualifiedName] (',' superTypes+=[NodeBlock|QualifiedName])*))?
	('{'
	(propertyStatements+=PropertyStatement | relationStatements+=RelationStatement)*
	'}')?;

Constraint:
	 'constraint' name=QualifiedName '=' constraints+=TypeReference (('&&' | '||') constraints+=TypeReference)*;

// types a Pattern/Rule can refine; maybe add NodeBlock?
SuperTypes:
	Metamodel | Model | Pattern | Rule
;

// split between atomic condition and constraint (needed to fix syntax)
TypeReference:
	ConditionTypes | (operator?='!')? constraints+=[Constraint|QualifiedName]
;

ConditionTypes:
	NegativeConstraintBody | PositiveConstraintBody | ImplicationBody
;
	
NegativeConstraintBody:
	'forbid' pattern=[Pattern|QualifiedName];
	
PositiveConstraintBody:
	'enforce' pattern=[Pattern|QualifiedName];
	
ImplicationBody:
	'if' premise=[Pattern|QualifiedName] 'then' conclusion=[Pattern|QualifiedName];

PropertyStatement:
	'.' name=ID ':' value=PropertyValue; 

PropertyValue:
	INT | ID;

RelationStatement:
	(action=Action)? '-' name=ID '->' value=[NodeBlock|QualifiedName] ('{' propertyStatements+=PropertyStatement* '}')?;

QualifiedName:
	ID ('.' ID)*;

Action:
	op=Operator;

enum Operator:
	CREATE='++' | DELETE='--';
	
