grammar org.emoflon.neo.emsl.EMSL with org.eclipse.xtext.common.Terminals

generate eMSL "http://www.emoflon.org/neo/emsl/EMSL"

/* An EMSL consists of a set of imports and entities */
EMSL_Spec:
	imports+=ImportStatement* entities+=Entity+;

/* Other EMSL files can be imported, optionally via an alias to resolve name clashes of entities in the imported files */
ImportStatement:
	'import' value=STRING ('as' alias=ID)?;

/* EMSL entities cover metamodelling and graph transformation */
Entity:
	Model | Metamodel | Pattern | Constraint | Rule | GraphGrammar | TripleRule | TripleGrammar;

/*-------------------------------------------------*/
/*------------------- Models ----------------------*/
/*-------------------------------------------------*/
Model:
	'model' name=QualifiedName 
	('->' (superRefinementTypes+=RefinementCommand (',' superRefinementTypes+=RefinementCommand)*))? 
	('{' nodeBlocks+=ModelNodeBlock* '}')?;

ModelNodeBlock:
	(action=Action)? name=ID ':' type=[MetamodelNodeBlock|QualifiedName]
	('{'
	(properties+=ModelPropertyStatement | relations+=ModelRelationStatement)*
	'}')?;

ModelPropertyStatement:
	'.' type=[MetamodelPropertyStatement|ID] op=ConditionOperator value=Value;

Value:
	AttributeExpression | EnumValue | PrimitiveInt | PrimitiveBoolean | PrimitiveString
;

AttributeExpression:
	node=[ModelNodeBlock|ID] target=(LinkAttributeExpTarget | NodeAttributeExpTarget)
;

LinkAttributeExpTarget:
	'-' link=[ModelRelationStatement|ID] '->::' attribute=[MetamodelPropertyStatement|ID]
;

NodeAttributeExpTarget:
	 '::' attribute=[MetamodelPropertyStatement|ID]
;

EnumValue:
	'enum::' literal=[EnumLiteral|ID]
;

PrimitiveInt:
	literal=INT
;

PrimitiveString:
	literal=STRING
;

PrimitiveBoolean:
	True?='true' | {PrimitiveBoolean} 'false'
;

ModelRelationStatement:
	(action=Action)? '-' type=[MetamodelRelationStatement|QualifiedName] '->' (target=[ModelNodeBlock|QualifiedName] | '$' proxyTarget=ID)
	('{'
	properties+=ModelPropertyStatement*
	'}')?;

/*-------------------------------------------------*/
/*----------------- Metamodels --------------------*/
/*-------------------------------------------------*/
Metamodel:
	'metamodel' name=QualifiedName 
	('->' (superRefinementTypes+=MetamodelRefinementCommand (',' superRefinementTypes+=MetamodelRefinementCommand)*))?
	('{' (nodeBlocks+=MetamodelNodeBlock | enums+=Enum)* '}')?;

MetamodelNodeBlock:
	(abstract?='abstract')? name=ID
	(':' superTypes+=[MetamodelNodeBlock|QualifiedName] (',' superTypes+=[MetamodelNodeBlock|QualifiedName])*)?
	('{'
	(properties+=MetamodelPropertyStatement | relations+=MetamodelRelationStatement)*
	'}')?;

MetamodelPropertyStatement:
	'.' name=ID ':' type=DataType;

MetamodelRelationStatement:
	kind=RelationKind name=ID
	'(' lower=MultiplicityValue '..' upper=MultiplicityValue ')' '->' (target=[MetamodelNodeBlock|QualifiedName] | '$' proxyTarget=ID)
	('{'
	properties+=MetamodelPropertyStatement*
	'}')?;

MultiplicityValue:
	INT | "*";

enum RelationKind:
	REFERENCE='-' | AGGREGATION='<>-' | KOMPOSITION='<+>-';

Enum:
	'enum' name=QualifiedName '{'
	literals+=EnumLiteral+
	'}';

EnumLiteral:
	name=ID;

DataType:
	BuiltInType | UserDefinedType;

BuiltInType:
	reference=BuiltInDataTypes;

UserDefinedType:
	reference=[Enum|QualifiedName];

enum BuiltInDataTypes:
	EBOOLEAN='EBoolean'
	| ESTRING='EString'
	| ECHAR='EChar'
	| EINT='EInt'
	| EDOUBLE='EDouble'
	| ELONG='ELong'
	| EFLOAT='EFloat'
	| EDATE='EDate';

/*-------------------------------------------------*/
/*------------------ Patterns ---------------------*/
/*-------------------------------------------------*/
AtomicPattern:
	'pattern' name=QualifiedName
	('->' (superRefinementTypes+=RefinementCommand (',' superRefinementTypes+=RefinementCommand)*))?
	('{'
	nodeBlocks+=ModelNodeBlock*
	'}')?;

Pattern:
	body=AtomicPattern ('when' condition=Condition)?;

Condition:
	AtomicConstraint | ConstraintReference;

AtomicConstraint returns ConstraintBody:
	NegativeConstraint | PositiveConstraint | Implication;

NegativeConstraint:
	'forbid' pattern=[AtomicPattern|QualifiedName];

PositiveConstraint:
	'enforce' pattern=[AtomicPattern|QualifiedName];

Implication:
	'if' premise=[AtomicPattern|QualifiedName] 'then' conclusion=[AtomicPattern|QualifiedName];

ConstraintReference:
	(negated?='!')? reference=[Constraint|QualifiedName];

Constraint:
	'constraint' name=QualifiedName '=' body=(AtomicConstraint | OrBody);

OrBody returns ConstraintBody:
	children+=AndBody ('||' children+=AndBody)*;

AndBody returns ConstraintBody:
	children+=Primary ('&&' children+=Primary)*;

Primary returns ConstraintBody:
	ConstraintReference | '(' OrBody ')';

/*-------------------------------------------------*/
/*------------------- Rules -----------------------*/
/*-------------------------------------------------*/
Rule:
	(abstract?='abstract')? 'rule' name=QualifiedName
	('->' (superRefinementTypes+=RefinementCommand (',' superRefinementTypes+=RefinementCommand)*))?
	('{'
	nodeBlocks+=ModelNodeBlock*
	('attributeConditions' '{' attributeConditions+=AttributeCondition* '}')?
	'}')? ('when' condition=Condition)?;

AttributeCondition:
	operator=LibraryAttributeCondition '(' (bindings+=ParameterBinding)? (',' bindings+=ParameterBinding)* ')';

enum LibraryAttributeCondition:
	EQ='eq' |
	ADD='add' |
	SUB='sub' |
	DIVIDE='divide' |
	MULTIPLY='multiply' |
	MAX='max' |
	MIN='min' |
	ADDPREFIX='addPrefix' |
	ADDSUFFIX='addSuffix' |
	CONCAT='concat' |
	SETDEFAULTNumber='setDefaultNumber' |
	SETDEFAULTSTRING='setDefaultString' |
	SETRANDOMSTRING='setRandomString' |
	SMALLEROREQUAL='smallerOrEqual' |
	STRINGTODOUBLE='stringToDouble' |
	STRINGTOINT='stringToInt' 
	;

GraphGrammar:
	'grammar' name=QualifiedName '{'
	rules+=[Rule|QualifiedName]+
	'}';

/*-------------------------------------------------*/
/*---------------- Triple Rules -------------------*/
/*-------------------------------------------------*/
TripleRule:
	(abstract?='abstract')? 'tripleRule' name=QualifiedName ':' type=[TripleGrammar|QualifiedName]
	('->' (superRefinementTypes+=RefinementCommand (',' superRefinementTypes+=RefinementCommand)*))?
	('{'
	('source' '{' srcNodeBlocks+=ModelNodeBlock* '}')?
	('target' '{' trgNodeBlocks+=ModelNodeBlock* '}')?
	('correspondence' '{' correspondences+=Correspondence* '}')?
	('attributeConditions' '{' attributeConditions+=AttributeCondition* '}')?
	'}')? ('forbid' nacs+=TripleRuleNAC ('&&' nacs+=TripleRuleNAC)*)?;

Correspondence:
	((action=Action)?
	source=[ModelNodeBlock|QualifiedName]
	'<-' ':' type=[CorrespondenceType|QualifiedName] '->'
	target=[ModelNodeBlock|QualifiedName]);

CorrespondenceType:
	source=[MetamodelNodeBlock|QualifiedName] '<-' name=QualifiedName '->' target=[MetamodelNodeBlock|QualifiedName];

ParameterBinding:
	(pre?='\'')? name=ID (post?='\'')? ':' value=(Value | TemporaryVariable | IgnoredVariable)
;

TemporaryVariable returns Value:
	'$' name=ID
;

IgnoredVariable returns Value:
	{IgnoredVariable} '_'
;

TripleRuleNAC:
	SourceNAC | TargetNAC;

SourceNAC:
	'src(' pattern=[AtomicPattern|QualifiedName] ')';

TargetNAC:
	'trg(' pattern=[AtomicPattern|QualifiedName] ')';

TripleGrammar:
	'tripleGrammar' name=QualifiedName '{'
	'source' '{' srcMetamodels+=[Metamodel|QualifiedName]* '}'
	'target' '{' trgMetamodels+=[Metamodel|QualifiedName]* '}'
	'correspondence' '{' correspondences+=CorrespondenceType* '}'
	'}'
	;

/*-------------------------------------------------*/
/*------------------- Common ----------------------*/
/*-------------------------------------------------*/
RefinementCommand:
	referencedType=[SuperType|QualifiedName] ('[' relabeling+=ModelRelabelingCommand (',' relabeling+=ModelRelabelingCommand)* ']')?;

MetamodelRefinementCommand:
	referencedType=[SuperType|QualifiedName] ('[' relabeling+=MetamodelRelabelingCommand (',' relabeling+=MetamodelRelabelingCommand)* ']')?;

ModelRelabelingCommand returns RelabelingCommand:
	oldLabel=ID '->' newLabel=ID;
	
MetamodelRelabelingCommand returns RelabelingCommand:
	oldLabel=ID '->' newLabel=ID;

SuperType:
	Metamodel | Model | AtomicPattern | Rule | TripleRule;

QualifiedName:
	ID ('.' ID)*;

Action:
	op=ActionOperator;

enum ActionOperator:
	CREATE='++' | DELETE='--';

enum ConditionOperator:
	NOTEQ='!=' | LESS='<' | LESSEQ='<=' | EQ=':' | GREATER='>' | GREATEREQ='>=' | ASSIGN=':=';


