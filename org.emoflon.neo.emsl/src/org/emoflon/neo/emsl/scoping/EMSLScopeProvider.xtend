/*
 * generated by Xtext 2.16.0
 */
package org.emoflon.neo.emsl.scoping

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.eclipse.xtext.util.SimpleAttributeResolver
import org.emoflon.neo.emsl.eMSL.EMSLPackage
import org.emoflon.neo.emsl.eMSL.ImportStatement
import org.emoflon.neo.emsl.eMSL.Metamodel
import org.emoflon.neo.emsl.eMSL.Model
import org.emoflon.neo.emsl.eMSL.NodeBlock
import org.emoflon.neo.emsl.eMSL.Pattern
import org.emoflon.neo.emsl.eMSL.RelationStatement
import org.emoflon.neo.emsl.eMSL.Rule
import org.emoflon.neo.emsl.eMSL.TripleRule
import org.emoflon.neo.emsl.eMSL.MetamodelNodeBlock
import org.emoflon.neo.emsl.eMSL.PropertyStatement
import org.emoflon.neo.emsl.eMSL.MetamodelRelationStatement
import org.emoflon.neo.emsl.eMSL.MetamodelPropertyStatement

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class EMSLScopeProvider extends AbstractEMSLScopeProvider {

	override getScope(EObject context, EReference reference) {
		if (typeOfNodeBlock(context, reference)) {
			if (isInModel(context as NodeBlock))
				return handleNodeBlockTypesInModel(context as NodeBlock, reference)
			else if (isInPattern(context as NodeBlock))
				return handleNodeBlockTypesInPattern(context as NodeBlock, reference)
			else if (isInRule(context as NodeBlock))
				return handleNodeBlockTypesInRule(context as NodeBlock, reference)
		}
		
		if (superTypeOfNodeBlock(context, reference)) {
			return handleSuperTypesOfNodeBlock(context as NodeBlock, reference)
		}

		if (valueOfRelationStatementInRule(context, reference))
			return handleValueOfRelationStatementInRule(context as RelationStatement, reference)
		
		if (valueOfRelationStatementInPattern(context, reference))
			return handleValueOfRelationStatementInPattern(context as RelationStatement, reference)
		
		if (valueOfRelationStatementInTripleRule(context, reference)) {
			return handleValueOfRelationStatementInTripleRule(context as RelationStatement, reference)
		}
		
		if (nameOfRelationStatementInModel(context, reference)) {
			return handleNameOfRelationStatement(context as RelationStatement, reference)
		}
		
		if (nameOfPropertyStatement(context, reference)) {
			return handleNameOfPropertyStatement(context as PropertyStatement, reference)
		}
		
		if (nameOfPropertyStatementInRelationStatement(context, reference))
			return handleNameOfPropertyStatementInRelationStatement(context as PropertyStatement, reference)
		
		if (valueOfPropertyStatementInMetamodel(context, reference))
			return handleValueOfPropertyStatementInMetamodel(context as MetamodelPropertyStatement, reference)
		
		if (isNodeBlockInMetamodel(context, reference))
			return handleNodeBlockTypesInMetamodel(context as MetamodelNodeBlock, reference)
		
		return super.getScope(context, reference)
	}
	
	def isNodeBlockInMetamodel(EObject context, EReference reference) {
		context instanceof MetamodelNodeBlock && reference == EMSLPackage.Literals.METAMODEL_NODE_BLOCK__TYPE &&
			context.eContainer instanceof Metamodel
	}
	
	def nameOfPropertyStatement(EObject context, EReference reference) {
		context instanceof PropertyStatement && reference == EMSLPackage.Literals.PROPERTY_STATEMENT__PROPERTY_NAME &&
			!(context.eContainer instanceof RelationStatement)
	}
	
	def handleNameOfPropertyStatement(EObject context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		var nodeBlocks = new HashMap<EObject, String>()

		nodeBlocks = (allNodeBlocksInAllImportedMetamodels(root))
		
		val possibilities = new HashMap
		for (nb : nodeBlocks.keySet) {
			(nb as MetamodelNodeBlock).metamodelPropertyStatements.forEach[r | possibilities.put(r, null)]
		}

		determineScope(possibilities)
	}
	
	def valueOfPropertyStatementInMetamodel(EObject context, EReference reference) {
		context instanceof MetamodelPropertyStatement && reference == EMSLPackage.Literals.METAMODEL_PROPERTY_STATEMENT__VALUE &&
			(context.eContainer instanceof MetamodelNodeBlock || context.eContainer instanceof MetamodelRelationStatement)
	}
	
	def handleValueOfPropertyStatementInMetamodel(MetamodelPropertyStatement context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		var enums = allTypesInAllImportedMetamodels(root, org.emoflon.neo.emsl.eMSL.Enum)
		
		val enumElements = new HashMap
		enums.forEach[p1, p2|
			(p1 as org.emoflon.neo.emsl.eMSL.Enum).enumItems.forEach[e | enumElements.put(e, null)]
		]
		
		determineScope(enumElements)
	}
	
	def nameOfPropertyStatementInRelationStatement(EObject context, EReference reference) {
		context instanceof PropertyStatement && reference == EMSLPackage.Literals.PROPERTY_STATEMENT__PROPERTY_NAME
	}
	
	def handleNameOfPropertyStatementInRelationStatement(EObject context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		var nodeBlocks = new HashMap<EObject, String>()

		nodeBlocks = (allNodeBlocksInAllImportedMetamodels(root))
		
		val possibilities = new HashMap
		for (nb : nodeBlocks.keySet) {
			(nb as MetamodelNodeBlock).metamodelRelationStatements.forEach[r | 
				(r as MetamodelRelationStatement).propertyStatements.forEach[p |
					possibilities.put(p, null)
				]
			]
		}

		determineScope(possibilities)
	}
	
	def nameOfRelationStatementInModel(EObject context, EReference reference) {
		context instanceof RelationStatement && reference == EMSLPackage.Literals.RELATION_STATEMENT__RELATION_NAME
	}
	
	def handleNameOfRelationStatement(EObject context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		var nodeBlocks = new HashMap<EObject, String>()

		nodeBlocks = (allNodeBlocksInAllImportedMetamodels(root))
		
		val possibilities = new HashMap
		for (nb : nodeBlocks.keySet) {
			(nb as MetamodelNodeBlock).metamodelRelationStatements.forEach[r | possibilities.put(r, null)]
		}

		determineScope(possibilities)
	}

	def valueOfRelationStatementInRule(EObject context, EReference reference) {
		context instanceof RelationStatement && reference == EMSLPackage.Literals.RELATION_STATEMENT__VALUE &&
			context.eContainer?.eContainer instanceof Rule
	}

	def handleValueOfRelationStatementInRule(RelationStatement statement, EReference reference) {
		val rule = statement.eContainer.eContainer as Rule
		val allNodeBlocks = new HashSet()
		val nodeBlocksInSuperTypes = rule.superTypes.filter[st|st instanceof Rule].flatMap[r|(r as Rule).nodeBlocks]
		allNodeBlocks.addAll(nodeBlocksInSuperTypes.toList)
		allNodeBlocks.addAll(rule.nodeBlocks)
		return Scopes.scopeFor(allNodeBlocks)
	}
	
	def valueOfRelationStatementInTripleRule(EObject context, EReference reference) {
		context instanceof RelationStatement && reference == EMSLPackage.Literals.RELATION_STATEMENT__VALUE &&
			context.eContainer?.eContainer instanceof TripleRule
	}

	def handleValueOfRelationStatementInTripleRule(RelationStatement statement, EReference reference) {
		val tripleRule = statement.eContainer.eContainer as TripleRule
		val allNodeBlocks = new HashSet()
		// only source
		if (tripleRule.srcNodeBlocks.contains(statement.eContainer as NodeBlock)) {
			val nodeBlocksInSuperTypes = tripleRule.superTypes.filter[st|st instanceof TripleRule].flatMap[r|(r as TripleRule).srcNodeBlocks]
			allNodeBlocks.addAll(nodeBlocksInSuperTypes.toList)
			allNodeBlocks.addAll(tripleRule.srcNodeBlocks)
		}
		else if (tripleRule.trgNodeBlocks.contains(statement.eContainer as NodeBlock)){
			val nodeBlocksInSuperTypes = tripleRule.superTypes.filter[st|st instanceof TripleRule].flatMap[r|(r as TripleRule).trgNodeBlocks]
			allNodeBlocks.addAll(nodeBlocksInSuperTypes.toList)
			allNodeBlocks.addAll(tripleRule.trgNodeBlocks)
		}
		return Scopes.scopeFor(allNodeBlocks)
	}
	
	def valueOfRelationStatementInPattern(EObject context, EReference reference) {
		context instanceof RelationStatement && reference == EMSLPackage.Literals.RELATION_STATEMENT__VALUE &&
			context.eContainer?.eContainer instanceof Pattern
	}

	def handleValueOfRelationStatementInPattern(RelationStatement statement, EReference reference) {
		val pattern = statement.eContainer.eContainer as Pattern
		val allNodeBlocks = new HashSet()
		val nodeBlocksInSuperTypes = pattern.superTypes.filter[st|st instanceof Pattern].flatMap[r|(r as Pattern).nodeBlocks]
		allNodeBlocks.addAll(nodeBlocksInSuperTypes.toList)
		allNodeBlocks.addAll(pattern.nodeBlocks)
		return Scopes.scopeFor(allNodeBlocks)
	}

	def <T extends EObject> determineScope(Map<EObject, String> aliases) {
		new SimpleScope(IScope.NULLSCOPE, Scopes.scopedElementsFor(
			aliases.keySet,
			[ eob |
				// find duplicates in names of NodeBlocks (works)
				val nameList = newArrayList
				val duplicateNames = newArrayList
				aliases.keySet.forEach[e | 
					if(!nameList.contains(QualifiedName.create(SimpleAttributeResolver.NAME_RESOLVER.apply(e)).toString))
						nameList.add(QualifiedName.create(SimpleAttributeResolver.NAME_RESOLVER.apply(e)).toString)
					else
						duplicateNames.add(QualifiedName.create(SimpleAttributeResolver.NAME_RESOLVER.apply(e)).toString)
				]
				// create QualifiedNames for NodeBlocks
				val eobName = SimpleAttributeResolver.NAME_RESOLVER.apply(eob)				
				if (duplicateNames.contains(eobName)) {
					if (aliases.containsKey(eob) && aliases.get(eob) !== null)
						QualifiedName.create(aliases.get(eob), SimpleAttributeResolver.NAME_RESOLVER.apply(eob.eContainer), eobName)
					else
						QualifiedName.create(SimpleAttributeResolver.NAME_RESOLVER.apply(eob.eContainer), eobName)
				}
				else {
					if (aliases.containsKey(eob) && aliases.get(eob) !== null)
						QualifiedName.create(aliases.get(eob), eobName)
					else
						QualifiedName.create(eobName)
				}
			]
		))
	}
	
	def handleSuperTypesOfNodeBlock(NodeBlock block, EReference reference) {
		val root = EcoreUtil2.getRootContainer(block)
		determineScope(allNodeBlocksInAllImportedMetamodels(root))
	}

	def superTypeOfNodeBlock(EObject context, EReference reference) {
		context instanceof NodeBlock && reference == EMSLPackage.Literals.NODE_BLOCK__SUPER_TYPES
	}

	// For a metamodel, candidates are only the EClass node block in NeoCore
	def handleNodeBlockTypesInMetamodel(MetamodelNodeBlock context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		new FilteringScope(determineScope(allNodeBlocksInAllImportedMetamodels(root)), [ desc |
			desc.name.lastSegment == "EClass"
		])
	}

	// For all entities other than metamodels, candidates are all node blocks of all imported metamodels
	def handleNodeBlockTypesInModel(NodeBlock context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		determineScope(allNodeBlocksInAllImportedMetamodels(root))
	}

	def handleNodeBlockTypesInPattern(NodeBlock context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		// For a Pattern, first check all metamodels for classes
		determineScope(allNodeBlocksInAllImportedMetamodels(root))
	}

	def handleNodeBlockTypesInRule(NodeBlock context, EReference reference) {
		val root = EcoreUtil2.getRootContainer(context)
		val possibilities = new HashMap<EObject, String>()

		possibilities.putAll(allNodeBlocksInAllImportedMetamodels(root))

		determineScope(possibilities)
	}

	def allNodeBlocksInAllImportedMetamodels(EObject root) {
		allTypesInAllImportedMetamodels(root, MetamodelNodeBlock)
	}

	def <T extends EObject> allTypesInAllImportedMetamodels(EObject root, Class<T> type) {
		val aliases = new HashMap<EObject, String>()
		val importStatements = EcoreUtil2.getAllContentsOfType(root, ImportStatement)
		for (st : importStatements) {
			try {
				val sp = loadEMSL_Spec(st.value, root)
				EcoreUtil2.getAllContentsOfType(sp, type).forEach [ o |
					aliases.put(o, if(st.alias == "") null else st.alias)
				]
			} catch (Exception e) {
				println(e)
			}
		}

		// Don't forget all node blocks in the same file
		EcoreUtil2.getAllContentsOfType(root, type).forEach[o|aliases.put(o, null)]

		aliases
	}

	def loadEMSL_Spec(String uri, EObject root) {
		val rs = root.eResource.resourceSet
		val resource = rs.getResource(URI.createURI(uri), true)
		resource.contents.get(0)
	}

	def isInMetamodel(NodeBlock context) {
		context.eContainer instanceof Metamodel
	}

	def isInModel(NodeBlock context) {
		context.eContainer instanceof Model
	}

	def isInPattern(NodeBlock context) {
		context.eContainer instanceof Pattern
	}

	def isInRule(NodeBlock context) {
		context.eContainer instanceof Rule
	}

	def typeOfNodeBlock(EObject context, EReference reference) {
		context instanceof NodeBlock && reference == EMSLPackage.Literals.NODE_BLOCK__TYPE
	}
}
