/*
 * generated by Xtext 2.16.0
 */
package org.emoflon.neo.emsl.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.function.Consumer
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.emoflon.neo.emsl.eMSL.ActionOperator
import org.emoflon.neo.emsl.eMSL.AtomicPattern
import org.emoflon.neo.emsl.eMSL.AttributeExpression
import org.emoflon.neo.emsl.eMSL.BinaryExpression
import org.emoflon.neo.emsl.eMSL.BuiltInDataTypes
import org.emoflon.neo.emsl.eMSL.BuiltInType
import org.emoflon.neo.emsl.eMSL.Condition
import org.emoflon.neo.emsl.eMSL.ConditionOperator
import org.emoflon.neo.emsl.eMSL.Constraint
import org.emoflon.neo.emsl.eMSL.ConstraintReference
import org.emoflon.neo.emsl.eMSL.Correspondence
import org.emoflon.neo.emsl.eMSL.EMSLPackage
import org.emoflon.neo.emsl.eMSL.EMSL_Spec
import org.emoflon.neo.emsl.eMSL.EnumValue
import org.emoflon.neo.emsl.eMSL.GraphGrammar
import org.emoflon.neo.emsl.eMSL.Implication
import org.emoflon.neo.emsl.eMSL.LinkAttributeExpTarget
import org.emoflon.neo.emsl.eMSL.Metamodel
import org.emoflon.neo.emsl.eMSL.MetamodelNodeBlock
import org.emoflon.neo.emsl.eMSL.MetamodelPropertyStatement
import org.emoflon.neo.emsl.eMSL.MetamodelRelationStatement
import org.emoflon.neo.emsl.eMSL.Model
import org.emoflon.neo.emsl.eMSL.ModelNodeBlock
import org.emoflon.neo.emsl.eMSL.ModelPropertyStatement
import org.emoflon.neo.emsl.eMSL.ModelRelationStatement
import org.emoflon.neo.emsl.eMSL.NegativeConstraint
import org.emoflon.neo.emsl.eMSL.Pattern
import org.emoflon.neo.emsl.eMSL.PositiveConstraint
import org.emoflon.neo.emsl.eMSL.PrimitiveBoolean
import org.emoflon.neo.emsl.eMSL.PrimitiveInt
import org.emoflon.neo.emsl.eMSL.PrimitiveString
import org.emoflon.neo.emsl.eMSL.RefinementCommand
import org.emoflon.neo.emsl.eMSL.Rule
import org.emoflon.neo.emsl.eMSL.SuperType
import org.emoflon.neo.emsl.eMSL.TripleGrammar
import org.emoflon.neo.emsl.eMSL.TripleRule
import org.emoflon.neo.emsl.eMSL.UserDefinedType
import org.emoflon.neo.emsl.eMSL.ValueExpression
import org.emoflon.neo.emsl.refinement.EMSLFlattener
import org.emoflon.neo.emsl.util.EntityAttributeDispatcher
import org.emoflon.neo.emsl.util.FlattenerErrorType
import org.emoflon.neo.emsl.util.FlattenerException

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EMSLValidator extends AbstractEMSLValidator {
	
	EntityAttributeDispatcher dispatcher
	
	new() {
		dispatcher = new EntityAttributeDispatcher()
	}

	// Error and info messages
	static final String WRONG_PROPERTY_TYPE = "The value of this property must be of type "
	static final String CONDITION_IN_SUPER_ENTITY = "Entities with conditions cannot be refined."
	static final String SAME_NAMES_OF_OBJECTS_IN_ENTITY = "Using the same name multiple times in one Entity is not allowed."
	static final def String REFINEMENT_LOOP(String refinement) '''You have created an infinite loop in your refinements. "«refinement»" appears multiple times.'''
	static final def String SAME_NAMES_OF_ENTITIES(String className) '''Two «className»s with the same name are not allowed.'''
	static final String GREEN_NODE_OF_ABSTRACT_TYPES = "Green Nodes of abstract types are not allowed"
	static final String NON_RESOLVABLE_PROXY = "A proxy target you defined could not be resolved."
	static final def String NON_MERGABLE_TYPES(String typeName) '''The type "«typeName»" in your refinements cannot be merged into a common subtype.'''
	static final String FORBIDDING_COMPLEX_EDGES = "Complex Edges in Models are not allowed."
	static final String ENTITY_TYPE_NOT_SUPPORTED = "Mixing entities in refinements is not allowed."
	static final String INSTANTIATING_ABSTRACT_TYPE_IN_NON_ABSTRACT_MODEL = "Instantiating an abstract type in a non-abstract model is not allowed."
	static final def String REDEFINITION_OF_CLASS_FEATURES(String feature, String superclass) '''Redefinition of features is not allowed: The feature "«feature»" is already defined in super class "«superclass»".'''
	static final def String TRIPLE_RULE_INSTANTIATION_ERROR(String section) '''The class you want to instantiate must be from a metamodel that is given in the TripleGrammar's «section» part.'''
	static final String COMPLEX_EDGE_WITH_OPERATOR = "Green/Red edges with multiple types are not allowed"
	static final String EDGE_WITH_OPERATOR_AND_PATH_LENGTH = "Green/Red edges with path lengths are not allowed"
	static final def String NO_COMMON_SUBTYPE(String name) '''The type "«name»" in your refinements cannot be merged into a common subtype.'''
	static final def String NON_MATCHING_ATTR_VALUES(String name) '''The value of "«name»" does not match your other refinements'''
	static final def String DIFFERENT_TYPES_OF_ATTRIBUTES(String type1, String type2) '''The types of the properties you are trying to refine are not compatible. The types "«type1»" and "«type2»" must be the same.'''
	static final String DIFFERENT_OPERATORS_OF_PROPERTIES = "The operators of the properties you are trying to refine are not compatible."
	static final String FORBIDDEN_ACTIONS = "Actions are not allowed here."
	static final String FORBIDDEN_NAMES_IN_EDGES = "Names in normal edges (only one type) are not allowed."
	static final String COLORED_EDGES_ADJACENT_TO_COLORED_NODES = "Edges adjacent to green/red nodes must be green/red"
	static final def String ONLY_RED_AND_GREEN_ELEMENTS(String type, String name) '''The «type»s called "«name»" in your refinements appear only red and green which is not allowed. To fix this, repeat this «type» without an operator.'''
	final static String SAME_NAME_ENUMS_CLASSES = "Using the same name twice for enums and/or classes is not allowed."
	static final def String SENSELESS_MULTIPLICITIES(String type) '''The upper bound in your «type» must be at least as big as your lower bound.'''
	static final String ENFORCING_NAMES_IN_EDGES = "Complex edges (more than one type) must have a name."

	/**
	 * Checks if the value given in ModelPropertyStatements is of the type that was defined for it 
	 * in the metamodel.
	 */
	@Check
	def checkPropertyStatementOfNodeBlock(ModelPropertyStatement p) {
		if (p.type instanceof MetamodelPropertyStatement) {
			if (p.type.type instanceof BuiltInType) {
				var propertyType = (p.type.type as BuiltInType).reference
				if (!isOfCorrectBuiltInType(p.value, propertyType))
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
			} else if (p.type.type instanceof UserDefinedType) {
				var propertyType = (p.type.type as UserDefinedType).reference
				if (!isOfCorrectUserDefinedType(p.value, p.type.type as UserDefinedType)) {
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
				}
			}
		}
	}

	def boolean isOfCorrectBuiltInType(ValueExpression expr, BuiltInDataTypes propertyType){
		if (expr instanceof PrimitiveInt) 
			propertyType == BuiltInDataTypes.EINT
		else if (expr instanceof PrimitiveBoolean)
			propertyType == BuiltInDataTypes.EBOOLEAN
		else if (expr instanceof PrimitiveString)
		 	propertyType == BuiltInDataTypes.ESTRING
		else if (expr instanceof AttributeExpression)
			expr.target.attribute.type instanceof BuiltInType && 
			(expr.target.attribute.type as BuiltInType).reference.equals(propertyType)
		else if(expr instanceof BinaryExpression)
			isOfCorrectBuiltInType(expr.left, propertyType) && isOfCorrectBuiltInType(expr.right, propertyType)
		else 
			false
	}

	/**
	 * Helper method for checking the values of AttributeExpressions for correctness in respect of the
	 * metamodel.
	 */
	def boolean isOfCorrectUserDefinedType(ValueExpression expr, UserDefinedType type) {
		if (expr instanceof AttributeExpression) {
			expr.target.attribute.type.equals(type)
		} else if (expr instanceof EnumValue)
			type.reference.literals.contains(expr.literal)
		else
			false
	}

	/**
	 * Tries to flatten the given Entity to find out if there are non-mergeable objects/statements etc.
	 * If an error occurs, an appropriate error message is shown.
	 * Also checks if the number of edges in the nodes is in accordance with the limits defined in the
	 * metamodel and if all properties have values assigned.
	 */	
	@Check(NORMAL)
	def checkFlatteningOfSuperType(SuperType entity) {
		try {
			var flattenedEntity = EMSLFlattener.flatten(entity);
			if (entity instanceof Model && !entity.abstract)
			dispatcher.getNodeBlocks(flattenedEntity).forEach[n |
				n.type.properties.forEach[p |
					var initialized = false
					for (otherP : n.properties) {
						if (otherP.type == p)
							initialized = true
					}
					if (!initialized)
						warning('''The property "«p.name»" of the class "«n.type.name»" in the object "«n.name»" has no value assigned.''', entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				]
				n.relations.forEach[r |
					r.types.forEach[t |
						t.type.properties.forEach[p |
							var initialized = false
							for (otherP : r.properties) {
								if (otherP.type == p)
									initialized = true
							}
							if (!initialized)
								warning('''The property "«p.name»" of the relation "«r.types.get(0).type.name»" in the object "«n.name»" has no value assigned.''', entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
						]
					]
				]
			]
			if (entity instanceof Model)
				checkNumberOfEdges(entity)
		} catch (FlattenerException e) {
			if (e.errorType == FlattenerErrorType.INFINITE_LOOP) {
				error(REFINEMENT_LOOP(dispatcher.getName(entity)),
						EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES)
			} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_NODES) {
				var index = 0
				for (nb : dispatcher.getNodeBlocks(entity)) {
					if (nb.type.name.equals(e.nodeBlock.type.name))
						error(NO_COMMON_SUBTYPE(e.nodeBlock.type.name), nb,
							EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.REFINE_ENTITY_WITH_CONDITION) {
				var index = 0
				for (s : entity.superRefinementTypes) {
					if (dispatcher.getName(s.referencedType).equals(dispatcher.getName(e.superEntity)))
						error(CONDITION_IN_SUPER_ENTITY, EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.NON_COMPLIANT_SUPER_ENTITY) {
				var dispatcher = dispatcher
				var index = 0
				for (s : dispatcher.getSuperRefinementTypes(entity)) {
					if (((s as RefinementCommand).referencedType.class !== entity.class) &&
							dispatcher.getSuperTypeName(e.superEntity).equals(
								dispatcher.getName((s as RefinementCommand).referencedType as SuperType))) {
						error(ENTITY_TYPE_NOT_SUPPORTED, entity,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					}
					index++
				}
			} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_PROPERTIES) {
				for (nb : dispatcher.getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name))
							error(DIFFERENT_TYPES_OF_ATTRIBUTES(
									(e.property1 as ModelPropertyStatement).type.name, (e.property2 as ModelPropertyStatement).type.name),
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
					}
				}
			} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_OPERATORS) {
				for (nb : dispatcher.getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name))
							error(DIFFERENT_OPERATORS_OF_PROPERTIES,
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
					}
					for (relationStatement : nb.relations) {
						for (propertyStatement : relationStatement.properties) {
							if (propertyStatement.type.name.equals(e.property1.type.name)) {
								error(DIFFERENT_OPERATORS_OF_PROPERTIES,
									propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
							}
						}
					}
				}
			} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_VALUES) {
				for (nb : dispatcher.getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name)) {
							error(NON_MATCHING_ATTR_VALUES(e.property1.type.name),
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
						}
					}
					for (relationStatement : nb.relations) {
						for (propertyStatement : relationStatement.properties) {
							if (propertyStatement.type.name.equals(e.property1.type.name)) {
								error(NON_MATCHING_ATTR_VALUES(e.property2.type.name), propertyStatement,
									EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
							}
						}
					}
				}
			} else if (e.errorType == FlattenerErrorType.NON_RESOLVABLE_PROXY) {
				for (nb : dispatcher.getNodeBlocks(entity)) {
					if (nb.name.equals((e.relation.eContainer as ModelNodeBlock).name)) {
						error(
							NON_RESOLVABLE_PROXY,
							nb,
							EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME
						)
					}
				}
			} else if (e.errorType == FlattenerErrorType.ONLY_RED_AND_GREEN_NODES) {
				error(ONLY_RED_AND_GREEN_ELEMENTS("node", (e.elements.get(0) as ModelNodeBlock).name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
			} else if (e.errorType == FlattenerErrorType.ONLY_RED_AND_GREEN_EDGES) {
				error(ONLY_RED_AND_GREEN_ELEMENTS("edge", (e.elements.get(0) as ModelRelationStatement).types.get(0).type.name), 
						entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
			} else if (e.errorType == FlattenerErrorType.PATH_LENGTHS_NONSENSE) {
				error(SENSELESS_MULTIPLICITIES("multiplicities"), EMSLPackage.Literals.SUPER_TYPE__NAME)
			} else if (e.errorType == FlattenerErrorType.NON_RESOLVABLE_CORR_PROXY_SOURCE) {
				for (c : (entity as TripleRule).correspondences) {
					if (c.type == e.corr.type && c.proxySource.equals(e.proxyName))
						error('''The proxy "«c.proxySource»" could not be resolved during flattening.''', c, EMSLPackage.Literals.CORRESPONDENCE__PROXY_SOURCE)
				}
			} else if (e.errorType == FlattenerErrorType.NON_RESOLVABLE_CORR_PROXY_TARGET) {
				for (c : (entity as TripleRule).correspondences) {
					if (c.type == e.corr.type && c.proxyTarget.equals(e.proxyName))
						error('''The proxy "«c.proxyTarget»" could not be resolved during flattening.''', c, EMSLPackage.Literals.CORRESPONDENCE__PROXY_TARGET)
				}
			}
		}
	}
	
	/**
	 * Helper method to handle Exceptions that are not entity specific.
	 */
	def handleCommonFlattenerExceptions(FlattenerException e, SuperType entity) {
		
	}

	@Check
	def checkForEntitiesWithSameName(EMSL_Spec spec) {
		var namelistsOfEntities = new HashMap<String, ArrayList<String>>();
		namelistsOfEntities.put("Pattern", new ArrayList<String>())
		namelistsOfEntities.put("Rule", new ArrayList<String>())
		namelistsOfEntities.put("Model", new ArrayList<String>())
		namelistsOfEntities.put("Metamodel", new ArrayList<String>())
		namelistsOfEntities.put("TripleRule", new ArrayList<String>())
		namelistsOfEntities.put("TripleGrammar", new ArrayList<String>())
		namelistsOfEntities.put("GraphGrammar", new ArrayList<String>())
		namelistsOfEntities.put("Constraint", new ArrayList<String>())

		for (entity : spec.entities) {
			var dispatcher = dispatcher
			if (!namelistsOfEntities.get(entity.eClass.name).contains(dispatcher.getName(entity))) {
				namelistsOfEntities.get(entity.eClass.name).add(dispatcher.getName(entity))
			} else {
				if (entity instanceof Rule)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof Model)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof Metamodel)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.METAMODEL__NAME)
				else if (entity instanceof TripleRule)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof TripleGrammar)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.TRIPLE_GRAMMAR__NAME)
				else if (entity instanceof GraphGrammar)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.GRAPH_GRAMMAR__NAME)
				else if (entity instanceof Constraint)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.CONSTRAINT__NAME)
				else if (entity instanceof Pattern)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity.body, EMSLPackage.Literals.SUPER_TYPE__NAME)
			}
		}
	}

	/**
	 * We are currently able to handle if/else structures as constraints only if they are not mixed with other constraints.
	 */
	@Check(NORMAL)
	def void checkIfElseAsConstraint(Constraint c) {
		if (c.body instanceof Implication)
			return
		else
			forbidIfElseAsChild(c.body, [o |
			error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" cannot be referenced from other constraints.''',
				EMSLPackage.Literals.CONSTRAINT__BODY)
		])
	}

	/**
	 * We currently do not support arbitrarily deep nesting
	 */
	@Check(NORMAL)
	def void forbidNesting(NegativeConstraint np) {
		val atomicPattern = np.pattern
		val parentPattern = atomicPattern.eContainer as Pattern
		if(parentPattern !== null && parentPattern.condition !== null){
			error('''Forbidden patterns cannot have conditions as arbitrary nesting is not supported.''',
					EMSLPackage.Literals.NEGATIVE_CONSTRAINT__PATTERN)
		}
	}

	/**
	 * We currently do not support arbitrarily deep nesting
	 */
	@Check(NORMAL)
	def void forbidNesting(PositiveConstraint pp) {
		val atomicPattern = pp.pattern
		val parentPattern = atomicPattern.eContainer as Pattern
		if(parentPattern !== null && parentPattern.condition !== null){
			error('''Enforced patterns cannot have conditions as arbitrary nesting is not supported.''',
					EMSLPackage.Literals.POSITIVE_CONSTRAINT__PATTERN)
		}
	}

	/**
	 * We currently do not support arbitrarily deep nesting
	 */
	@Check(NORMAL)
	def void forbidNesting(Implication ip) {
		val premise = ip.premise
		val conclusion = ip.conclusion

		val premisePattern = premise.eContainer as Pattern
		val conclusionPattern = conclusion.eContainer as Pattern

		if (premisePattern !== null && premisePattern.condition !== null) {
			error('''Patterns used as premise cannot have conditions as arbitrary nesting is not supported.''',
				EMSLPackage.Literals.IMPLICATION__PREMISE)
		}

		if (conclusionPattern !== null && conclusionPattern.condition !== null) {
			error('''Patterns used as conclusion cannot have conditions as arbitrary nesting is not supported.''',
				EMSLPackage.Literals.IMPLICATION__CONCLUSION)
		}
	}

	/**
	 * We are currently unable to handle if/else structures as application conditions for patterns.
	 * This is related to the transformation to the underlying pattern matcher.
	 */
	@Check(NORMAL)
	def void forbidIfElseAsChild(Pattern p) {
		if (p.condition !== null) {
			forbidIfElseAsChild(p.condition, [o |
				error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" are currently not supported as part of application conditions''',
					EMSLPackage.Literals.PATTERN__CONDITION)
			])
		}
	}

	private def void forbidIfElseAsChild(Condition c, Consumer<Implication> error) {
		var allConditions = new ArrayList<EObject>()
		allConditions.add(c)
		allConditions.addAll(c.eAllContents.toList)
		allConditions.filter[it instanceof Implication].forEach [
			error.accept(it as Implication)
		]

		allConditions.filter[it instanceof ConstraintReference].forEach [
			var refCond = (it as ConstraintReference).reference.body
			forbidIfElseAsChild(refCond, error)
		]
	}

	/**
	 * Checks if a modelNodeBlock's action contains an operator. As this does not make sense for models
	 * an error message is shown.
	 */
	@Check
	def void forbidOperatorsInModelNodeBlocks(ModelNodeBlock m) {
		if (!(m.eContainer instanceof Rule) && !(m.eContainer instanceof TripleRule)) {
			if (m.action !== null) {
				error(FORBIDDEN_ACTIONS, m, EMSLPackage.Literals.MODEL_NODE_BLOCK__ACTION)
			}
			for (r : m.relations) {
				if (r.action !== null) {
					error(FORBIDDEN_ACTIONS, r, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__ACTION)
				}
			}
		}
	}
	
	/**
	 * Checks if multiple nodeBlocks in a metamodel have the same name. If so, an error is produced.
	 */
	@Check
	def void forbidNodeBlocksWithSameNameInMetamodel(Metamodel entity) {
		var namesList = new HashSet<String>()
		for (nb : entity.nodeBlocks) {
			if (!namesList.contains(nb.name))
				namesList.add(nb.name)
			else {
				error(SAME_NAME_ENUMS_CLASSES, nb, EMSLPackage.Literals.METAMODEL_NODE_BLOCK__NAME)
				for (other : entity.enums) {
					if (other.name.equals(nb.name))
						error(SAME_NAME_ENUMS_CLASSES, other, EMSLPackage.Literals.ENUM__NAME)
				}
				for (other : entity.nodeBlocks) {
					if (other.name.equals(nb.name))
						error(SAME_NAME_ENUMS_CLASSES, other, EMSLPackage.Literals.METAMODEL_NODE_BLOCK__NAME)
				}	
			}
		}
		for (e : entity.enums) {
			if (!namesList.contains(e.name))
				namesList.add(e.name)
			else {
				error(SAME_NAME_ENUMS_CLASSES, e, EMSLPackage.Literals.ENUM__NAME)
				for (other : entity.enums) {
					if (other.name.equals(e.name))
						error(SAME_NAME_ENUMS_CLASSES, other, EMSLPackage.Literals.ENUM__NAME)
				}
				for (other : entity.nodeBlocks) {
					if (other.name.equals(e.name))
						error(SAME_NAME_ENUMS_CLASSES, other, EMSLPackage.Literals.METAMODEL_NODE_BLOCK__NAME)
				}
			}
		}
	}
	
	/**
	 * Checks if multiple nodeBlocks and/or edges in an entity have the same name.
	 * This is forbidden because Relabeling of nodeBlocks and/or edges would no longer work.
	 */
	@Check
	def void forbidNodeBlockAndEdgeWithSameName(SuperType entity) {
		var dispatcher = dispatcher
		var namesList = new ArrayList
		
		var listOfNodeBlocks = new ArrayList;
		if(entity instanceof Pattern)
			listOfNodeBlocks.addAll(dispatcher.getPatternNodeBlocks(entity))
		else if(entity instanceof SuperType)
			listOfNodeBlocks.addAll(dispatcher.getNodeBlocks(entity))
		
		if (!(entity instanceof TripleRule)) {
			for (nb : listOfNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
		} else if (entity instanceof TripleRule) {
			for (nb : entity.srcNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
			for (nb : entity.trgNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
		}
	}
	
	/**
	 * Checks if a normal edge (edges that has only one given type) has a name. If so, an error is produced.
	 */
	@Check
	def void forbidNamesInNormalEdges(ModelRelationStatement relation) {
		if (relation.types.size == 1 && relation.name !== null) {
			error(FORBIDDEN_NAMES_IN_EDGES, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
		}
	}
	
	/**
	 * Checks if a complex edge has a name. If not, an error is produced.
	 */
	@Check
	def void enforceNamesInComplexEdges(ModelRelationStatement relation) {
		if (relation.types.size > 1 && relation.name === null) {
			error(ENFORCING_NAMES_IN_EDGES, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
		}
	}
	
	/**
	 * Checks if edges adjacent to green/red nodes are green/red themselves.
	 */
	@Check
	def void checkOperatorsOfEdgesAdjacentToNodes(ModelRelationStatement relation) {
		if (relation.eContainer.eContainer instanceof Rule || relation.eContainer.eContainer instanceof TripleRule) {
			if (relation.action === null && relation.target?.action !== null 
					|| (relation.action === null && (relation.eContainer as ModelNodeBlock).action !== null)) {
				error(COLORED_EDGES_ADJACENT_TO_COLORED_NODES, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
			}
		}
	}
	
	/**
	 * Checks if a green node in a Rule or TripleRule is of abstract type.
	 * Because abstract types cannot be created in a rule or TripleRule this is
	 * forbidden by the editor.
	 */
	@Check
	def void forbidGreenNodesOfAbstractTypesInRule(ModelNodeBlock nb) {
		if ((nb.eContainer instanceof Rule && !(nb.eContainer as Rule).abstract 
					|| nb.eContainer instanceof TripleRule && !(nb.eContainer as TripleRule).abstract) 
				&& nb.action?.op === ActionOperator.CREATE && nb.type.abstract) {
			error(GREEN_NODE_OF_ABSTRACT_TYPES, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__ACTION)
		}
	}
	
	/**
	 * Checks if a non-abstract model instantiates abstract classes.
	 */
	@Check
	def void forbidInstancesOfAbstractTypesInNonAbstractModels(Model model) {
		for (nb : model.nodeBlocks) {
			if (!(model.abstract) && nb.type.abstract) {
				error(INSTANTIATING_ABSTRACT_TYPE_IN_NON_ABSTRACT_MODEL, 
					nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
			}
		}
	}
	
	/**
	 * Checks if a model contains complex edges (edges with multiple types). Since they have
	 * no meaning in models, it is forbidden.
	 */
	@Check
	def void forbidComplexEdgesInModels(ModelRelationStatement relation) {
		if (relation.eContainer.eContainer instanceof Model) {
			if (relation.types.size > 1) {
				error(FORBIDDING_COMPLEX_EDGES, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
			}
			if (relation.lower !== null || relation.upper !== null) {
				try {
					error("Path lengths in models are not allowed.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__LOWER)
				} catch (Exception e) {
					error("Path lengths in models are not allowed.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__UPPER)
				}
			}
		}
	}
	
	/**
	 * Checks if a class of a metamodel redefines a property of its superclasses
	 */
	@Check
	def void forbidRedefinitionOfClassFeatures(Metamodel entity) {
		for (nb : entity.nodeBlocks) {
			if (!nb.superTypes.isEmpty) {
				nb.properties.forEach[p |
					nb.superTypes.forEach[st |
						findPropertyRedefinitions(p, st)
					]
				]
				nb.relations.forEach[r |
					nb.superTypes.forEach[st |
						findRelationRedefinitions(r, st)
					]
				]
			}
		}
	}
	
	/**
	 * Helper method to find redefinitions of properties recursively.
	 */
	def void findPropertyRedefinitions(MetamodelPropertyStatement property, MetamodelNodeBlock superclass) {
		if (superclass.properties.map[sp | sp.name].contains(property.name)) {
			error(REDEFINITION_OF_CLASS_FEATURES(property.name, superclass.name), property, EMSLPackage.Literals.METAMODEL_PROPERTY_STATEMENT__NAME)
		}
		superclass.superTypes.forEach[s | findPropertyRedefinitions(property, s)]
	}
	
	/**
	 * Helper method to find redefinitions of relations recursively.
	 */
	def void findRelationRedefinitions(MetamodelRelationStatement relation, MetamodelNodeBlock superclass) {
		if (superclass.relations.map[sr | sr.name].contains(relation.name)) {
			error(REDEFINITION_OF_CLASS_FEATURES(relation.name, superclass.name), relation, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__NAME)
		}
		superclass.superTypes.forEach[s | findRelationRedefinitions(relation, s)]
	}
	
	/**
	 * Checks if the nodeblocks of a tripleRule instantiate only classes that are contained in the metamodels
	 * that are specified in the rule's grammar.
	 */
	@Check
	def void checkInstantiationOfMetamodelsInTripleRule(TripleRule tripleRule) {
		for (nb : tripleRule.srcNodeBlocks) {
			val wrapper = new Object() {var correct = false;}
			tripleRule.type.srcMetamodels.map[m | m.nodeBlocks].forEach[m |
				if (m.contains(nb.type))
					wrapper.correct = true
			]
			if (!wrapper.correct)
				error(TRIPLE_RULE_INSTANTIATION_ERROR("source"), nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
		}
		for (nb : tripleRule.trgNodeBlocks) {
			val wrapper = new Object() {var correct = false;}
			tripleRule.type.trgMetamodels.map[m | m.nodeBlocks].toSet.forEach[m |
				if (m.contains(nb.type))
					wrapper.correct = true
			]
			if (!wrapper.correct)
					error(TRIPLE_RULE_INSTANTIATION_ERROR("target"), nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
		}
	}
	
	/**
	 * Checks if a red/green edge (inside rule/tripleRule) is a complex edge.
	 * Since this can not be handled it is forbidden.
	 */
	@Check (NORMAL)
	def void forbidComplexEdgesInGreenRedEdges (ModelRelationStatement relation) {
		if (relation.action !== null) {
			if (relation.types.size > 1) {
				error(COMPLEX_EDGE_WITH_OPERATOR, relation.types.get(1), EMSLPackage.Literals.MODEL_RELATION_STATEMENT_TYPE__TYPE)
			} else if (relation.lower !== null) {
				error(EDGE_WITH_OPERATOR_AND_PATH_LENGTH, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__LOWER)
			}
		}
	}
	
	/**
	 * Searches for cycles in the inheritance hierarchy of classes in a metamodel.
	 */
	@Check (NORMAL)
	def void forbidInheritanceCyclesOfClasses(Metamodel metamodel) {
		for (nb : metamodel.nodeBlocks)
			inheritanceCycleHelper(nb, new HashSet)
	}
	
	/**
	 * Helper method to find cycles in the inheritance hierarchy in a metamodel recursively.
	 */
	def void inheritanceCycleHelper(MetamodelNodeBlock nb, HashSet<MetamodelNodeBlock> superclasses) {
		var index = 0
		for (sc : nb.superTypes) {
			if (superclasses.contains(sc))
				error("You have a cycle in your inheritance", nb, EMSLPackage.Literals.METAMODEL_NODE_BLOCK__SUPER_TYPES, index)
			var superCloned = superclasses.clone as HashSet<MetamodelNodeBlock>
			superCloned.add(sc)
			inheritanceCycleHelper(sc, superCloned)
			index++
		}
	}
	
	/**
	 * Two attributes in a class can not have the same name.
	 */
	@Check (NORMAL)
	def void forbidSameNameOfAttributes(MetamodelNodeBlock nb) {
		var attrNames = new HashSet<String>
		for (attr : nb.properties) {
			if (attrNames.contains(attr.name)) {
				error(SAME_NAMES_OF_ENTITIES("attribute"), attr, EMSLPackage.Literals.METAMODEL_PROPERTY_STATEMENT__NAME)
				for (other : nb.properties) {
					if (other.name.equals(attr.name))
						error(SAME_NAMES_OF_ENTITIES("attribute"), other, EMSLPackage.Literals.METAMODEL_PROPERTY_STATEMENT__NAME)
				}
			}
			attrNames.add(attr.name)
		}
	}
	
	/**
	 * Two references in a class can not have the same name.
	 */
	@Check (NORMAL)
	def void forbidSameNameOfReferences(MetamodelNodeBlock nb) {
		var refNames = new HashSet<String>
		for (ref : nb.relations) {
			if (refNames.contains(ref.name)) {
				error(SAME_NAMES_OF_ENTITIES("reference"), ref, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__NAME)
				for (other : nb.relations) {
					if (other.name.equals(ref.name))
						error(SAME_NAMES_OF_ENTITIES("reference"), other, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__NAME)
				}
			}
			refNames.add(ref.name)
		}
	}

	/**
	 * Checks the multiplicities of MetamodelRelationStatements if they are valid.
	 * (E.g. nothing like (5..1) ).
	 */
	@Check
	def void checkMultiplicities(MetamodelRelationStatement relation) {
		try {
			if (Integer.parseInt(relation.lower) > Integer.parseInt(relation.upper)) {
				error(SENSELESS_MULTIPLICITIES("path lengths"), relation, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__LOWER)
				error(SENSELESS_MULTIPLICITIES("path lengths"), relation, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__UPPER)
				}
		} catch (NumberFormatException e) {
			if (!(relation.upper.equals("*"))) {
				error(SENSELESS_MULTIPLICITIES("path lengths"), relation, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__LOWER)
				error(SENSELESS_MULTIPLICITIES("path lengths"), relation, EMSLPackage.Literals.METAMODEL_RELATION_STATEMENT__UPPER)
			}
		}
	}
	
	/**
	 * Checks if the number of edges in a nodeBlock is consistent with the number of
	 * edges defined in the metamodel.
	 */
	def void checkNumberOfEdges(Model entity) {
		for (nb : entity.nodeBlocks) {
			nb.type.relations.forEach[r |
				var numberOfInstances = nb.relations.filter[instance |
					instance.types.get(0).type == r
				].size
				if (!r.lower.equals("*") && !(numberOfInstances >= Integer.parseInt(r.lower)))
					error('''You need at least «Integer.parseInt(r.lower)» edges of type "«r.name»" in your nodeBlock.''', nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__RELATIONS)
				if (!r.upper.equals("*") && !(numberOfInstances <= Integer.parseInt(r.upper)))
					error('''You can create at most «Integer.parseInt(r.upper)» edges of type "«r.name»" in your nodeBlock.''', nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__RELATIONS)
			]
		}
	}
	
	/**
	 * Checks if the names of correspondences defined in the TripleGrammar are unique.
	 */
	@Check
	def void checkForUniqueNamesOfCorrespondences(TripleGrammar entity) {
		var corrNames = new HashSet<String>
		for (corr : entity.correspondences) {
			if (corrNames.contains(corr.name)) {
				error(SAME_NAMES_OF_ENTITIES("correspondence"), corr, EMSLPackage.Literals.CORRESPONDENCE_TYPE__NAME)
				for (other : entity.correspondences) {
					if (other.name.equals(corr.name))
						error(SAME_NAMES_OF_ENTITIES("correspondence"), other, EMSLPackage.Literals.CORRESPONDENCE_TYPE__NAME)
				}
			}
			corrNames.add(corr.name)
		}
	}
	
	/**
	 * Checks if a correspondence that is adjacent to red/green nodes is also red/green.
	 */
	@Check
	def void correspondencesAdjacentToRedGreenNodes(Correspondence corr) {
		if (corr.action === null && corr.source?.action !== null) {
			error("Correspondences adjacent to red/green nodes must also be red/green", corr, EMSLPackage.Literals.CORRESPONDENCE__SOURCE)
		}
		if (corr.action === null && corr.target?.action !== null) {
			error("Correspondences adjacent to red/green nodes must also be red/green", corr, EMSLPackage.Literals.CORRESPONDENCE__TARGET)
		}
	}
	
	/**
	 * Checks if the types of source and target of a correspondence match those defined in the
	 * TripleGrammar for this correspondence.
	 */
	@Check
	def void typeOfSourceTargetInCorrespondence(Correspondence corr) {
		if (corr.source?.type != corr.type.source) {
			error('''The source argument must be of type "«corr.type.source.name»".''', corr, EMSLPackage.Literals.CORRESPONDENCE__SOURCE)
		}
		if (corr.target?.type != corr.type.target) {
			error('''The target argument must be of type "«corr.type.target.name»".''', corr, EMSLPackage.Literals.CORRESPONDENCE__TARGET)
		}
	}
	
	/**
	 * Checks if the types given in an edge are transitively reachable and their
	 * target types make sense, i.e. are helping in reaching the desired target.
	 */
	@Check
	def void checkTypesUsedInRelationStatements(ModelRelationStatement relation) {
		if (relation.types.size > 1) {
			var index = 0
			for (t : relation.types) {
				if (!(t.type.eContainer == (relation.eContainer as ModelNodeBlock).type)) {
					var reachable = false
					var usefulTarget = false
					for (other : relation.types) {
						if (t.type.eContainer == other.type.target)
							reachable = true
						if (t.type.target == other.type.eContainer)
							usefulTarget = true
					}
					if (!reachable)
						error('''The edge-type "«t.type.name»" is not allowed here because it is not transitively reachable.''', relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES, index)
					if (!usefulTarget)
						error('''The edge-type "«t.type.name»" is not allowed here because its target makes no sense.''', relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES, index)
				}
				index++
			}
		}
	}
	
	/**
	 * Checks if the ConditionOperator used in ModelPropertyStatements is allowed to be used.
	 */
	@Check
	def void checkAttributeStatementOperators(ModelPropertyStatement statement) {
		if ((statement.eContainer.eContainer instanceof Model || statement.eContainer.eContainer.eContainer instanceof Model) && statement.op !== ConditionOperator.EQ) {
			error("This operator is not allowed in models. Use \":\" instead.", statement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__OP)
		} else if ((statement.eContainer.eContainer instanceof AtomicPattern || statement.eContainer.eContainer.eContainer instanceof AtomicPattern) && statement.op === ConditionOperator.ASSIGN) {
			error("This operator is not allowed in patterns. Use a conditional operator instead.", statement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__OP)
		}
	}
	
	/**
	 * Validates the LinkAttributeExpTarget statements because the scoping is not specific enough.
	 */
	@Check
	def void validateLinkAttributeExpression(LinkAttributeExpTarget exp) {
		if (exp.link.target !== exp.target.type) {
			error('''The target of the link type "«exp.link»" must be of type "«exp.link.target»".''', exp, EMSLPackage.Literals.LINK_ATTRIBUTE_EXP_TARGET__TARGET)
		} else {
			var valid = false
			for (r : (exp.eContainer as AttributeExpression).node.relations) {
				if (r.types.map[t | t.type].contains(exp.link) && r.types.size == 1 && exp.target === r.target) {
					valid = true
				}
			}
			if (!valid) {
				error('''The edge from "«(exp.eContainer as AttributeExpression).node.name»" to "«exp.target.name»" of type "«exp.link.name»" must exist in "«(exp.eContainer as AttributeExpression).node.name»".''', 
						exp, EMSLPackage.Literals.LINK_ATTRIBUTE_EXP_TARGET__TARGET
				)
			}
		}
	}
	
	/**
	 * Checks if the lower bound of a path is smaller or equal to the upper bound.
	 */
	@Check
	def void checkBoundsOfPaths(ModelRelationStatement relation) {
		if (relation.upper !== null) {
			try {
				if (relation.lower !== null && relation.upper !== null
						&& Integer.parseInt(relation.lower) > Integer.parseInt(relation.upper)) {
					error("The lower bound of your path lengths must be smaller than the upper bound.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__LOWER)
					error("The lower bound of your path lengths must be smaller than the upper bound.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__UPPER)
				}
			} catch (NumberFormatException e) {
				if (relation.lower.equals("*") && !relation.upper.equals("*")) {	
					error("The lower bound of your path lengths must be smaller than the upper bound.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__LOWER)
					error("The lower bound of your path lengths must be smaller than the upper bound.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__UPPER)
				}
			}
		}
	}
}
