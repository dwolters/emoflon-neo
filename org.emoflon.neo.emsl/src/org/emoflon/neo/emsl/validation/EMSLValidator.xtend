/*
 * generated by Xtext 2.16.0
 */
package org.emoflon.neo.emsl.validation

import java.util.ArrayList
import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.emoflon.neo.emsl.EMSLFlattener
import org.emoflon.neo.emsl.eMSL.AtomicPattern
import org.emoflon.neo.emsl.eMSL.AttributeExpression
import org.emoflon.neo.emsl.eMSL.BuiltInDataTypes
import org.emoflon.neo.emsl.eMSL.BuiltInType
import org.emoflon.neo.emsl.eMSL.Condition
import org.emoflon.neo.emsl.eMSL.Constraint
import org.emoflon.neo.emsl.eMSL.ConstraintReference
import org.emoflon.neo.emsl.eMSL.DataType
import org.emoflon.neo.emsl.eMSL.EMSLPackage
import org.emoflon.neo.emsl.eMSL.EMSL_Spec
import org.emoflon.neo.emsl.eMSL.Entity
import org.emoflon.neo.emsl.eMSL.EnumValue
import org.emoflon.neo.emsl.eMSL.GraphGrammar
import org.emoflon.neo.emsl.eMSL.Implication
import org.emoflon.neo.emsl.eMSL.LinkAttributeExpTarget
import org.emoflon.neo.emsl.eMSL.Metamodel
import org.emoflon.neo.emsl.eMSL.MetamodelPropertyStatement
import org.emoflon.neo.emsl.eMSL.Model
import org.emoflon.neo.emsl.eMSL.ModelNodeBlock
import org.emoflon.neo.emsl.eMSL.ModelPropertyStatement
import org.emoflon.neo.emsl.eMSL.NodeAttributeExpTarget
import org.emoflon.neo.emsl.eMSL.Pattern
import org.emoflon.neo.emsl.eMSL.PrimitiveBoolean
import org.emoflon.neo.emsl.eMSL.PrimitiveInt
import org.emoflon.neo.emsl.eMSL.PrimitiveString
import org.emoflon.neo.emsl.eMSL.RefinementCommand
import org.emoflon.neo.emsl.eMSL.Rule
import org.emoflon.neo.emsl.eMSL.TripleGrammar
import org.emoflon.neo.emsl.eMSL.TripleRule
import org.emoflon.neo.emsl.eMSL.UserDefinedType
import org.emoflon.neo.emsl.util.EntityAttributeDispatcher
import org.emoflon.neo.emsl.util.FlattenerErrorType
import org.emoflon.neo.emsl.util.FlattenerException
import java.util.function.Consumer

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EMSLValidator extends AbstractEMSLValidator {

	static final String WRONG_PROPERTY_TYPE = "The value of this property must be of type "
	// TODO [Maximilian] find other way (no splitting) maybe give template??
	static final String REFINEMENT_LOOP_1 = "You have created an infinite loop in your refinements. \""
	static final String REFINEMENT_LOOP_2 = "\" appears multiple times."
	static final String CONDITION_IN_SUPER_ENTITY = "Entities with conditions cannot be refined."
	static final String NOT_SUPPORTED_ENTITY = "The type of entity you are trying to refine is not yet supported."

	/**
	 * Checks if the value given in ModelPropertyStatements is of the type that was defined for it 
	 * in the metamodel.
	 */
	@Check
	def checkPropertyStatementOfNodeBlock(ModelPropertyStatement p) {
		if (p.type instanceof MetamodelPropertyStatement) {
			if (p.type.type instanceof BuiltInType) {
				var propertyType = (p.type.type as BuiltInType).reference

				if (!(p.value instanceof PrimitiveInt && propertyType == BuiltInDataTypes.EINT) &&
					!(p.value instanceof PrimitiveBoolean && propertyType == BuiltInDataTypes.EBOOLEAN) &&
					!(p.value instanceof PrimitiveString && propertyType == BuiltInDataTypes.ESTRING) &&
					!(p.value instanceof AttributeExpression &&
						isOfCorrectType(p.value as AttributeExpression, p.type.type)))
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
			} else if (p.type.type instanceof UserDefinedType) {
				var propertyType = (p.type.type as UserDefinedType).reference
				var literals = propertyType.literals
				if (!(p.value instanceof EnumValue && literals.contains((p.value as EnumValue).literal))) {
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
				}
			}
		}
	}

	/**
	 * Helper method for checking the values of AttributeExpressions for correctness in respect of the
	 * metamodel.
	 */
	def isOfCorrectType(AttributeExpression attrExpr, DataType type) {
		if (attrExpr.target instanceof NodeAttributeExpTarget) {
			(attrExpr.target as NodeAttributeExpTarget).attribute.type.equals(type)
		} else if (attrExpr.target instanceof LinkAttributeExpTarget) {
			return (attrExpr.target as LinkAttributeExpTarget).attribute.type.equals(type)
		}
	}

	/**
	 * Tries to flatten the given Entity to find out if there are non-mergeable objects/statements etc.
	 * If an error occurs, an appropriate error message is shown.
	 */
	@Check(NORMAL)
	def checkFlattening(Entity entity) {
		try {
			if (entity instanceof Pattern) {
				new EMSLFlattener().flattenCopyOfEntity(entity as Pattern, new ArrayList);
			} else if (entity instanceof Rule) {
				new EMSLFlattener().flattenCopyOfEntity(entity as Entity, new ArrayList);
			}
		} catch (FlattenerException e) {
			if (entity instanceof AtomicPattern) {
				if (e.errorType == FlattenerErrorType.INFINITE_LOOP) {
					var index = 0
					for (s : entity.superRefinementTypes) {
						if (e.alreadyRefinedPatternNames.contains((s.referencedType as AtomicPattern).name))
							error(
								REFINEMENT_LOOP_1 + new EntityAttributeDispatcher().getName(entity) + REFINEMENT_LOOP_2,
								entity, EMSLPackage.Literals.ATOMIC_PATTERN__SUPER_REFINEMENT_TYPES, index)
						index++
					}

				} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_NODES) {
					var index = 0
					for (nb : entity.nodeBlocks) {
						if (nb.type.name.equals(e.nodeBlock.type.name)) {
							error("The type " + e.nodeBlock.type.name +
								" in your refinements cannot be merged into a common subtype.", nb,
								EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
						}
						index++
					}

				} else if (e.errorType == FlattenerErrorType.REFINE_ENTITY_WITH_CONDITION) {
					var index = 0
					for (s : entity.superRefinementTypes) {
						if ((s.referencedType as AtomicPattern).name.equals((e.superEntity as AtomicPattern).name))
							error(CONDITION_IN_SUPER_ENTITY, entity,
								EMSLPackage.Literals.ATOMIC_PATTERN__SUPER_REFINEMENT_TYPES, index)
						index++
					}

				} else if (e.errorType == FlattenerErrorType.NON_COMPLIANT_SUPER_ENTITY) {
					var dispatcher = new EntityAttributeDispatcher()
					var index = 0
					for (s : dispatcher.getSuperRefinementTypes(entity)) {
						if (!((s as RefinementCommand).referencedType instanceof AtomicPattern) &&
							dispatcher.getSuperTypeName(e.superEntity).equals(
								dispatcher.getName((s as RefinementCommand).referencedType as Entity))) {
							error(NOT_SUPPORTED_ENTITY, entity,
								EMSLPackage.Literals.ATOMIC_PATTERN__SUPER_REFINEMENT_TYPES, index)
						} else if ((s as RefinementCommand).referencedType instanceof AtomicPattern &&
							dispatcher.getSuperTypeName(e.superEntity).equals(
								dispatcher.getName((s as RefinementCommand).referencedType as AtomicPattern))) {
							error(NOT_SUPPORTED_ENTITY, entity,
								EMSLPackage.Literals.ATOMIC_PATTERN__SUPER_REFINEMENT_TYPES, index)
						}
						index++
					}
				}
			} else if (entity instanceof Rule) {
				if (e.errorType == FlattenerErrorType.INFINITE_LOOP) {
					var index = 0
					for (s : entity.superRefinementTypes) {
						if ((s.referencedType as Rule).name.equals((e.superEntity as Rule).name))
							error(
								REFINEMENT_LOOP_1 + new EntityAttributeDispatcher().getName(entity) + REFINEMENT_LOOP_2,
								EMSLPackage.Literals.RULE__SUPER_REFINEMENT_TYPES, index)
						index++
					}

				} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_NODES) {
					var index = 0
					for (nb : entity.nodeBlocks) {
						if (nb.type.name.equals(e.nodeBlock.type.name))
							error("The type " + e.nodeBlock.type.name +
								" in your refinements cannot be merged into a common subtype.", nb,
								EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE, index)
						index++
					}

				} else if (e.errorType == FlattenerErrorType.REFINE_ENTITY_WITH_CONDITION) {
					var index = 0
					for (s : entity.superRefinementTypes) {
						if ((s.referencedType as Rule).name.equals((e.superEntity as Rule).name))
							error(CONDITION_IN_SUPER_ENTITY, EMSLPackage.Literals.RULE__SUPER_REFINEMENT_TYPES, index)
						index++
					}

				} else if (e.errorType == FlattenerErrorType.NON_COMPLIANT_SUPER_ENTITY) {
					var dispatcher = new EntityAttributeDispatcher()
					var index = 0
					for (s : dispatcher.getSuperRefinementTypes(entity)) {
						if (!((s as RefinementCommand).referencedType instanceof AtomicPattern) &&
							dispatcher.getSuperTypeName(e.superEntity).equals(
								dispatcher.getName((s as RefinementCommand).referencedType as Entity))) {

							error("The type of entity you are trying to refine is not supported yet.", entity,
								EMSLPackage.Literals.RULE__SUPER_REFINEMENT_TYPES, index)

						} else if ((s as RefinementCommand).referencedType instanceof AtomicPattern &&
							dispatcher.getSuperTypeName(e.superEntity).equals(
								dispatcher.getName((s as RefinementCommand).referencedType as AtomicPattern))) {

							error("The type of entity you are trying to refine is not yet supported.", entity,
								EMSLPackage.Literals.RULE__SUPER_REFINEMENT_TYPES, index)

						}
						index++
					}
				}
			}
			if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_PROPERTIES) {
				for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name))
							error(
								"The types of the properties you are trying to refine are not compatible. The types " +
									(e.property1 as ModelPropertyStatement).type.name + " and " +
									(e.property2 as ModelPropertyStatement).type.name + " must be the same.",
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
					}
				}
			} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_OPERATORS) {
				for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name))
							error("The operators of the properties you are trying to refine are not compatible.",
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
					}
					for (relationStatement : nb.relations) {
						for (propertyStatement : relationStatement.properties) {
							if (propertyStatement.type.name.equals(e.property1.type.name)) {
								error("The operators of the properties you are trying to refine are not compatible.",
									propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
							}
						}
					}
				}
			} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_VALUES) {
				for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
					for (propertyStatement : nb.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name)) {
							error("The value of " + e.property2.type.name + " does not match your other refinements",
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
						}
					}
					for (relationStatement : nb.relations) {
						for (propertyStatement : relationStatement.properties) {
							if (propertyStatement.type.name.equals(e.property1.type.name)) {
								error("The value of " + e.property2.type.name +
									" does not match your other refinements", propertyStatement,
									EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
							}
						}
					}
				}
			} else if (e.errorType == FlattenerErrorType.NON_RESOLVABLE_PROXY) {
				for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
					if (nb.name.equals((e.relation.eContainer as ModelNodeBlock).name)) {
						error(
							"A proxy target you defined could not be resolved.",
							nb,
							EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME
						)
					}
				}
			}
		}
	}

	@Check(NORMAL)
	def checkForEntitiesWithSameName(EMSL_Spec spec) {
		var namelistsOfEntities = new HashMap<String, ArrayList<String>>();
		namelistsOfEntities.put("Pattern", new ArrayList<String>())
		namelistsOfEntities.put("Rule", new ArrayList<String>())
		namelistsOfEntities.put("Model", new ArrayList<String>())
		namelistsOfEntities.put("Metamodel", new ArrayList<String>())
		namelistsOfEntities.put("TripleRule", new ArrayList<String>())
		namelistsOfEntities.put("TripleGrammar", new ArrayList<String>())
		namelistsOfEntities.put("GraphGrammar", new ArrayList<String>())
		namelistsOfEntities.put("Constraint", new ArrayList<String>())

		for (entity : spec.entities) {
			var dispatcher = new EntityAttributeDispatcher()
			if (!namelistsOfEntities.get(entity.eClass.name).contains(dispatcher.getName(entity))) {
				namelistsOfEntities.get(entity.eClass.name).add(dispatcher.getName(entity))
			} else {
				if (entity instanceof Rule)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.RULE__NAME)
				else if (entity instanceof Model)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.MODEL__NAME)
				else if (entity instanceof Metamodel)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.METAMODEL__NAME)
				else if (entity instanceof TripleRule)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.TRIPLE_RULE__NAME)
				else if (entity instanceof TripleGrammar)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.TRIPLE_GRAMMAR__NAME)
				else if (entity instanceof GraphGrammar)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.GRAPH_GRAMMAR__NAME)
				else if (entity instanceof Constraint)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity,
						EMSLPackage.Literals.CONSTRAINT__NAME)
				else if (entity instanceof Pattern)
					error("Two " + entity.eClass.name + "s with the same name are not allowed.", entity.body,
						EMSLPackage.Literals.ATOMIC_PATTERN__NAME)
			}
		}
	}

	/**
	 * We are currently able to handle if/else structures as constraints only if they are not mixed with other constraints.
	 */
	@Check(NORMAL)
	def void checkIfElseAsConstraint(Constraint c) {
		if (c.body instanceof Implication)
			return
		else
			forbidIfElseAsChild(c.body, [o |
			error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" cannot be referenced from other constraints.''',
				EMSLPackage.Literals.CONSTRAINT__BODY)
		])
	}

	/**
	 * We are currently unable to handle if/else structures as application conditions for patterns.
	 * This is related to the transformation to the underlying pattern matcher.
	 */
	@Check(NORMAL)
	def void forbidIfElseAsChild(Pattern p) {
		forbidIfElseAsChild(p.condition, [o |
			error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" are currently not supported as part of application conditions''',
				EMSLPackage.Literals.PATTERN__CONDITION)
		])
	}

	private def void forbidIfElseAsChild(Condition c, Consumer<Implication> error) {
		var allConditions = new ArrayList<EObject>()
		allConditions.add(c)
		allConditions.addAll(c.eAllContents.toList)
		allConditions.filter[it instanceof Implication].forEach [
			error.accept(it as Implication)
		]

		allConditions.filter[it instanceof ConstraintReference].forEach [
			var refCond = (it as ConstraintReference).reference.body
			forbidIfElseAsChild(refCond, error)
		]
	}

	/**
	 * Checks if a modelNodeBlock's action contains an operator. As this does not make sense for models
	 * an error message is shown.
	 */
	@Check
	def void forbidOperatorsInModelNodeBlocks(Model m) {
		for (nb : m.nodeBlocks) {
			if (nb.action !== null) {
				error("Actions are not allowed in Models.", nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__ACTION)
			}
		}
	}
}
