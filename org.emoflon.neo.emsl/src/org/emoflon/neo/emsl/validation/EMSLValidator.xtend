/*
 * generated by Xtext 2.16.0
 */
package org.emoflon.neo.emsl.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.function.Consumer
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.emoflon.neo.emsl.eMSL.AtomicPattern
import org.emoflon.neo.emsl.eMSL.AttributeExpression
import org.emoflon.neo.emsl.eMSL.BuiltInDataTypes
import org.emoflon.neo.emsl.eMSL.BuiltInType
import org.emoflon.neo.emsl.eMSL.Condition
import org.emoflon.neo.emsl.eMSL.Constraint
import org.emoflon.neo.emsl.eMSL.ConstraintReference
import org.emoflon.neo.emsl.eMSL.DataType
import org.emoflon.neo.emsl.eMSL.EMSLPackage
import org.emoflon.neo.emsl.eMSL.EMSL_Spec
import org.emoflon.neo.emsl.eMSL.Entity
import org.emoflon.neo.emsl.eMSL.EnumValue
import org.emoflon.neo.emsl.eMSL.GraphGrammar
import org.emoflon.neo.emsl.eMSL.Implication
import org.emoflon.neo.emsl.eMSL.LinkAttributeExpTarget
import org.emoflon.neo.emsl.eMSL.Metamodel
import org.emoflon.neo.emsl.eMSL.MetamodelPropertyStatement
import org.emoflon.neo.emsl.eMSL.Model
import org.emoflon.neo.emsl.eMSL.ModelNodeBlock
import org.emoflon.neo.emsl.eMSL.ModelPropertyStatement
import org.emoflon.neo.emsl.eMSL.ModelRelationStatement
import org.emoflon.neo.emsl.eMSL.NodeAttributeExpTarget
import org.emoflon.neo.emsl.eMSL.Pattern
import org.emoflon.neo.emsl.eMSL.PrimitiveBoolean
import org.emoflon.neo.emsl.eMSL.PrimitiveInt
import org.emoflon.neo.emsl.eMSL.PrimitiveString
import org.emoflon.neo.emsl.eMSL.RefinementCommand
import org.emoflon.neo.emsl.eMSL.Rule
import org.emoflon.neo.emsl.eMSL.SuperType
import org.emoflon.neo.emsl.eMSL.TripleGrammar
import org.emoflon.neo.emsl.eMSL.TripleRule
import org.emoflon.neo.emsl.eMSL.UserDefinedType
import org.emoflon.neo.emsl.refinement.EMSLFlattener
import org.emoflon.neo.emsl.util.EntityAttributeDispatcher
import org.emoflon.neo.emsl.util.FlattenerErrorType
import org.emoflon.neo.emsl.util.FlattenerException

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EMSLValidator extends AbstractEMSLValidator {

	// Error and info messages
	static final String WRONG_PROPERTY_TYPE = "The value of this property must be of type "
	static final String CONDITION_IN_SUPER_ENTITY = "Entities with conditions cannot be refined."
	static final String NOT_SUPPORTED_ENTITY = "The type of entity you are trying to refine is not yet supported."
	static final String SAME_NAMES_OF_OBJECTS_IN_ENTITY = "Using the same name multiple times in one Entity is not allowed."
	static final def String REFINEMENT_LOOP(String refinement) '''You have created an infinite loop in your refinements. "«refinement»" appears multiple times.'''
	static final def String SAME_NAMES_OF_ENTITIES(String className) '''Two «className»s with the same name are not allowed.'''
	static final String GREEN_NODE_OF_ABSTRACT_TYPES = "Green Nodes of abstract types are not allowed"
	static final String NON_RESOLVABLE_PROXY = "A proxy target you defined could not be resolved."
	static final def String NON_MERGABLE_TYPES(String typeName) '''The type «typeName»  in your refinements cannot be merged into a common subtype.'''
	static final String FORBIDDING_COMPLEX_EDGES = "Complex Edges in Models are not allowed."
	static final String ENTITY_TYPE_NOT_SUPPORTED = "The type of entity you are trying to refine is not supported yet."
	static final String INSTANTIATING_ABSTRACT_TYPE_IN_NON_ABSTRACT_MODEL = "Instantiating an abstract type in a non-abstract model is not allowed."

	/**
	 * Checks if the value given in ModelPropertyStatements is of the type that was defined for it 
	 * in the metamodel.
	 */
	@Check
	def checkPropertyStatementOfNodeBlock(ModelPropertyStatement p) {
		if (p.type instanceof MetamodelPropertyStatement) {
			if (p.type.type instanceof BuiltInType) {
				var propertyType = (p.type.type as BuiltInType).reference

				if (!(p.value instanceof PrimitiveInt && propertyType == BuiltInDataTypes.EINT) &&
					!(p.value instanceof PrimitiveBoolean && propertyType == BuiltInDataTypes.EBOOLEAN) &&
					!(p.value instanceof PrimitiveString && propertyType == BuiltInDataTypes.ESTRING) &&
					!(p.value instanceof AttributeExpression &&
						isOfCorrectType(p.value as AttributeExpression, p.type.type)))
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
			} else if (p.type.type instanceof UserDefinedType) {
				var propertyType = (p.type.type as UserDefinedType).reference
				var literals = propertyType.literals
				if (!(p.value instanceof EnumValue && literals.contains((p.value as EnumValue).literal))) {
					error(WRONG_PROPERTY_TYPE + propertyType.getName,
						EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__VALUE)
				}
			}
		}
	}

	/**
	 * Helper method for checking the values of AttributeExpressions for correctness in respect of the
	 * metamodel.
	 */
	def isOfCorrectType(AttributeExpression attrExpr, DataType type) {
		if (attrExpr.target instanceof NodeAttributeExpTarget) {
			(attrExpr.target as NodeAttributeExpTarget).attribute.type.equals(type)
		} else if (attrExpr.target instanceof LinkAttributeExpTarget) {
			return (attrExpr.target as LinkAttributeExpTarget).attribute.type.equals(type)
		}
	}

	/**
	 * Tries to flatten the given Entity to find out if there are non-mergeable objects/statements etc.
	 * If an error occurs, an appropriate error message is shown.
	 */
	@Check(NORMAL)
	def checkFlatteningOfPattern(Pattern entity) {
		try {
			EMSLFlattener.flatten(entity.body);
		} catch (FlattenerException e) {
			if (e.errorType == FlattenerErrorType.INFINITE_LOOP) {
				var index = 0
				for (s : new EntityAttributeDispatcher().getSuperRefinementTypes(entity)) {
					if (e.alreadyRefinedPatternNames.contains(((s as RefinementCommand).referencedType as AtomicPattern).name))
						error(
							REFINEMENT_LOOP(new EntityAttributeDispatcher().getName(entity)),
							entity.body, EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_NODES) {
				var index = 0
				for (nb : new EntityAttributeDispatcher().getPatternNodeBlocks(entity)) {
					if (nb.type.name.equals(e.nodeBlock.type.name)) {
						error(NON_MERGABLE_TYPES(e.nodeBlock.type.name), nb,
							EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
					}
					index++
				}

			} else if (e.errorType == FlattenerErrorType.REFINE_ENTITY_WITH_CONDITION) {
				var index = 0
				for (s : new EntityAttributeDispatcher().getSuperRefinementTypes(entity)) {
					if (((s as RefinementCommand).referencedType as AtomicPattern).name.equals((e.superEntity as AtomicPattern).name))
						error(CONDITION_IN_SUPER_ENTITY, entity.body,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.NON_COMPLIANT_SUPER_ENTITY) {
				var dispatcher = new EntityAttributeDispatcher()
				var index = 0
				for (s : dispatcher.getSuperRefinementTypes(entity)) {
					if (!((s as RefinementCommand).referencedType instanceof AtomicPattern) &&
						dispatcher.getSuperTypeName(e.superEntity).equals(
							dispatcher.getName((s as RefinementCommand).referencedType as Entity))) {
						error(NOT_SUPPORTED_ENTITY, entity.body,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					} else if ((s as RefinementCommand).referencedType instanceof AtomicPattern &&
						dispatcher.getSuperTypeName(e.superEntity).equals(
							dispatcher.getName((s as RefinementCommand).referencedType as AtomicPattern))) {
						error(NOT_SUPPORTED_ENTITY, entity.body,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					}
					index++
				}
			} else if (e.errorType == FlattenerErrorType.PATH_LENGTHS_NONSENSE) {
				error("Some path limits in your refinements do not make sense.", 
					entity.body, EMSLPackage.Literals.SUPER_TYPE__NAME)
			} else if (e.errorType == FlattenerErrorType.NO_INTERSECTION_IN_MODEL_RELATION_STATEMENT_TYPE_LIST) {
				error("There has to be at least one common type of edges in your refinements of complex edges.", 
					entity.body, EMSLPackage.Literals.SUPER_TYPE__NAME)
			} else {
				handleCommonFlattenerExceptions(e, entity.body)
			}
		}
	}
	
	@Check(NORMAL)
	def checkFlatteningOfRules(Rule entity) {
		try {
			EMSLFlattener.flatten(entity);
		} catch (FlattenerException e) {
			if (e.errorType == FlattenerErrorType.INFINITE_LOOP) {
				var index = 0
				for (s : entity.superRefinementTypes) {
					if ((s.referencedType as Rule).name.equals((e.superEntity as Rule).name))
						error(
							REFINEMENT_LOOP(new EntityAttributeDispatcher().getName(entity)),
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_NODES) {
				var index = 0
				for (nb : entity.nodeBlocks) {
					if (nb.type.name.equals(e.nodeBlock.type.name))
						error("The type " + e.nodeBlock.type.name +
							" in your refinements cannot be merged into a common subtype.", nb,
							EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.REFINE_ENTITY_WITH_CONDITION) {
				var index = 0
				for (s : entity.superRefinementTypes) {
					if ((s.referencedType as Rule).name.equals((e.superEntity as Rule).name))
						error(CONDITION_IN_SUPER_ENTITY, EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)
					index++
				}

			} else if (e.errorType == FlattenerErrorType.NON_COMPLIANT_SUPER_ENTITY) {
				var dispatcher = new EntityAttributeDispatcher()
				var index = 0
				for (s : dispatcher.getSuperRefinementTypes(entity)) {
					if (!((s as RefinementCommand).referencedType instanceof AtomicPattern) &&
						dispatcher.getSuperTypeName(e.superEntity).equals(
							dispatcher.getName((s as RefinementCommand).referencedType as Entity))) {

						error(ENTITY_TYPE_NOT_SUPPORTED, entity,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)

					} else if ((s as RefinementCommand).referencedType instanceof AtomicPattern &&
						dispatcher.getSuperTypeName(e.superEntity).equals(
							dispatcher.getName((s as RefinementCommand).referencedType as AtomicPattern))) {

						error(ENTITY_TYPE_NOT_SUPPORTED, entity,
							EMSLPackage.Literals.SUPER_TYPE__SUPER_REFINEMENT_TYPES, index)

					}
					index++
				}
			} else {
				handleCommonFlattenerExceptions(e, entity)
			}
		}
	}
	
	/**
	 * Helper method to handle Exceptions that are not entity specific.
	 */
	def handleCommonFlattenerExceptions(FlattenerException e, SuperType entity) {
		if (e.errorType == FlattenerErrorType.NO_COMMON_SUBTYPE_OF_PROPERTIES) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
				for (propertyStatement : nb.properties) {
					if (propertyStatement.type.name.equals(e.property1.type.name))
						error(
							"The types of the properties you are trying to refine are not compatible. The types " +
								(e.property1 as ModelPropertyStatement).type.name + " and " +
								(e.property2 as ModelPropertyStatement).type.name + " must be the same.",
							propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
				}
			}
		} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_OPERATORS) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
				for (propertyStatement : nb.properties) {
					if (propertyStatement.type.name.equals(e.property1.type.name))
						error("The operators of the properties you are trying to refine are not compatible.",
							propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
				}
				for (relationStatement : nb.relations) {
					for (propertyStatement : relationStatement.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name)) {
							error("The operators of the properties you are trying to refine are not compatible.",
								propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
						}
					}
				}
			}
		} else if (e.errorType == FlattenerErrorType.PROPS_WITH_DIFFERENT_VALUES) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
				for (propertyStatement : nb.properties) {
					if (propertyStatement.type.name.equals(e.property1.type.name)) {
						error("The value of " + e.property2.type.name + " does not match your other refinements",
							propertyStatement, EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
					}
				}
				for (relationStatement : nb.relations) {
					for (propertyStatement : relationStatement.properties) {
						if (propertyStatement.type.name.equals(e.property1.type.name)) {
							error("The value of " + e.property2.type.name +
								" does not match your other refinements", propertyStatement,
								EMSLPackage.Literals.MODEL_PROPERTY_STATEMENT__TYPE)
						}
					}
				}
			}
		} else if (e.errorType == FlattenerErrorType.NON_RESOLVABLE_PROXY) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(entity)) {
				if (nb.name.equals((e.relation.eContainer as ModelNodeBlock).name)) {
					error(
						NON_RESOLVABLE_PROXY,
						nb,
						EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME
					)
				}
			}
		}
	}

	@Check(NORMAL)
	def checkForEntitiesWithSameName(EMSL_Spec spec) {
		var namelistsOfEntities = new HashMap<String, ArrayList<String>>();
		namelistsOfEntities.put("Pattern", new ArrayList<String>())
		namelistsOfEntities.put("Rule", new ArrayList<String>())
		namelistsOfEntities.put("Model", new ArrayList<String>())
		namelistsOfEntities.put("Metamodel", new ArrayList<String>())
		namelistsOfEntities.put("TripleRule", new ArrayList<String>())
		namelistsOfEntities.put("TripleGrammar", new ArrayList<String>())
		namelistsOfEntities.put("GraphGrammar", new ArrayList<String>())
		namelistsOfEntities.put("Constraint", new ArrayList<String>())

		for (entity : spec.entities) {
			var dispatcher = new EntityAttributeDispatcher()
			if (!namelistsOfEntities.get(entity.eClass.name).contains(dispatcher.getName(entity))) {
				namelistsOfEntities.get(entity.eClass.name).add(dispatcher.getName(entity))
			} else {
				if (entity instanceof Rule)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof Model)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof Metamodel)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.METAMODEL__NAME)
				else if (entity instanceof TripleRule)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.SUPER_TYPE__NAME)
				else if (entity instanceof TripleGrammar)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.TRIPLE_GRAMMAR__NAME)
				else if (entity instanceof GraphGrammar)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.GRAPH_GRAMMAR__NAME)
				else if (entity instanceof Constraint)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity, EMSLPackage.Literals.CONSTRAINT__NAME)
				else if (entity instanceof Pattern)
					error(SAME_NAMES_OF_ENTITIES(entity.eClass.name), entity.body, EMSLPackage.Literals.SUPER_TYPE__NAME)
			}
		}
	}

	/**
	 * We are currently able to handle if/else structures as constraints only if they are not mixed with other constraints.
	 */
	@Check(NORMAL)
	def void checkIfElseAsConstraint(Constraint c) {
		if (c.body instanceof Implication)
			return
		else
			forbidIfElseAsChild(c.body, [o |
			error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" cannot be referenced from other constraints.''',
				EMSLPackage.Literals.CONSTRAINT__BODY)
		])
	}

	/**
	 * We are currently unable to handle if/else structures as application conditions for patterns.
	 * This is related to the transformation to the underlying pattern matcher.
	 */
	@Check(NORMAL)
	def void forbidIfElseAsChild(Pattern p) {
		if (p.condition !== null) {
			forbidIfElseAsChild(p.condition, [o |
				error('''If/else conditions such as "if «o.premise.name» then «o.conclusion.name»" are currently not supported as part of application conditions''',
					EMSLPackage.Literals.PATTERN__CONDITION)
			])
		}
	}

	private def void forbidIfElseAsChild(Condition c, Consumer<Implication> error) {
		var allConditions = new ArrayList<EObject>()
		allConditions.add(c)
		allConditions.addAll(c.eAllContents.toList)
		allConditions.filter[it instanceof Implication].forEach [
			error.accept(it as Implication)
		]

		allConditions.filter[it instanceof ConstraintReference].forEach [
			var refCond = (it as ConstraintReference).reference.body
			forbidIfElseAsChild(refCond, error)
		]
	}

	/**
	 * Checks if a modelNodeBlock's action contains an operator. As this does not make sense for models
	 * an error message is shown.
	 */
	@Check
	def void forbidOperatorsInModelNodeBlocks(ModelNodeBlock m) {
		if (!(m.eContainer instanceof Rule) && !(m.eContainer instanceof TripleRule)) {
			if (m.action !== null) {
				error("Actions are not allowed here.", m, EMSLPackage.Literals.MODEL_NODE_BLOCK__ACTION)
			}
			for (r : m.relations) {
				if (r.action !== null) {
					error("Actions are not allowed here.", r, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__ACTION)
				}
			}
		}
	}
	
	/**
	 * Checks if multiple nodeBlocks in a metamodel have the same name. If so, an error is produced.
	 */
	@Check(NORMAL)
	def void forbidNodeBlocksWithSameNameInMetamodel(Entity entity) {
		var namesList = new ArrayList<String>()
		if (entity instanceof Metamodel) {
			for (nb : entity.nodeBlocks) {
				if (!namesList.contains(nb.name))
					namesList.add(nb.name)
				else
					error("Multiple Node Blocks with the same name are not allowed.", nb, EMSLPackage.Literals.METAMODEL_NODE_BLOCK__NAME)		
			}
		}
	}
	
	/**
	 * Checks if multiple nodeBlocks and/or edges in an entity have the same name.
	 * This is forbidden because Relabeling of nodeBlocks and/or edges would no longer work.
	 */
	@Check
	def void forbidNodeBlockAndEdgeWithSameName(Entity entity) {
		var dispatcher = new EntityAttributeDispatcher()
		var namesList = new ArrayList
		
		var listOfNodeBlocks = new ArrayList;
		if(entity instanceof Pattern)
			listOfNodeBlocks.addAll(dispatcher.getPatternNodeBlocks(entity))
		else if(entity instanceof SuperType)
			listOfNodeBlocks.addAll(dispatcher.getNodeBlocks(entity))
		
		if (!(entity instanceof TripleRule)) {
			for (nb : listOfNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
		} else if (entity instanceof TripleRule) {
			for (nb : entity.srcNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
			for (nb : entity.trgNodeBlocks) {
				if (!namesList.contains(nb.name)) {
					namesList.add(nb.name)
				} else {
					error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__NAME)
				}
				for (rel : nb.relations) {
					if (rel.name !== null && !namesList.contains(rel.name)) {
						namesList.add(rel.name)
					} else if (rel.name !== null) {
						error(SAME_NAMES_OF_OBJECTS_IN_ENTITY, rel, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
					}
				}
			}
		}
	}
	
	/**
	 * Checks if a normal edge (edges that has only one given type) has a name. If so, an error is produced.
	 */
	@Check
	def void forbidNamesInNormalEdges(ModelRelationStatement relation) {
		if (relation.types.size == 1 && relation.name !== null) {
			error("Names in normal edges (only one type) are not allowed.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__NAME)
		}
	}
	
	/**
	 * Checks if a complex edge has a name. If not, an error is produced.
	 */
	@Check
	def void enforceNamesInComplexEdges(ModelRelationStatement relation) {
		if (relation.types.size > 1 && relation.name === null) {
			error("Complex edges must have a name.", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
		}
	}
	
	/**
	 * Checks if edges adjacent to green/red nodes are green/red themselves.
	 */
	@Check
	def void checkOperatorsOfEdgesAdjacentToNodes(ModelRelationStatement relation) {
		if (relation.eContainer.eContainer instanceof Rule || relation.eContainer.eContainer instanceof TripleRule) {
			if (relation.action === null && relation.target.action !== null || (relation.action === null && (relation.eContainer as ModelNodeBlock).action !== null)) {
				error("Edges adjacent to green/red nodes must be green/red", relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
			}
		}
	}
	
	/**
	 * Checks if a green node in a Rule or TripleRule is of abstract type.
	 * Because abstract types cannot be created in a rule or TripleRule this is
	 * forbidden by the editor.
	 */
	@Check
	def void forbidGreenNodesOfAbstractTypesInRule(ModelNodeBlock nb) {
		if ((nb.eContainer instanceof Rule && !(nb.eContainer as Rule).abstract 
					|| nb.eContainer instanceof TripleRule && !(nb.eContainer as TripleRule).abstract) 
				&& nb.action !== null && nb.type.abstract) {
			error(GREEN_NODE_OF_ABSTRACT_TYPES, nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__ACTION)
		}
	}
	
	/**
	 * Checks if a non-abstract model instantiates abstract classes.
	 */
	@Check
	def void forbidInstancesOfAbstractTypesInNonAbstractModels(Model model) {
		for (nb : model.nodeBlocks) {
			if (!(model.abstract) && nb.type.abstract) {
				error(INSTANTIATING_ABSTRACT_TYPE_IN_NON_ABSTRACT_MODEL, 
					nb, EMSLPackage.Literals.MODEL_NODE_BLOCK__TYPE)
			}
		}
	}
	
	/**
	 * Checks if a model contains complex edges (edges with multiple types). Since they have
	 * no meaning in models, it is forbidden.
	 */
	@Check
	def void forbidComplexEdgesInModels(ModelRelationStatement relation) {
		if (relation.types.size > 1 && relation.eContainer.eContainer instanceof Model) {
			error(FORBIDDING_COMPLEX_EDGES, relation, EMSLPackage.Literals.MODEL_RELATION_STATEMENT__TYPES)
		}
	}
}
