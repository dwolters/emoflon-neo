/*
 * generated by Xtext 2.16.0
 */
package org.emoflon.neo.emsl.ui.contentassist

import java.util.HashSet
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.IResource
import org.eclipse.core.resources.IResourceVisitor
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.emoflon.neo.emsl.eMSL.AtomicPattern
import org.emoflon.neo.emsl.eMSL.Pattern
import org.emoflon.neo.emsl.eMSL.RefinementCommand
import org.emoflon.neo.emsl.eMSL.SuperType
import org.emoflon.neo.emsl.refinement.EMSLFlattener
import org.emoflon.neo.emsl.util.EntityAttributeDispatcher
import org.emoflon.neo.emsl.eMSL.ModelRelationStatement
import org.emoflon.neo.emsl.eMSL.Correspondence
import org.emoflon.neo.emsl.eMSL.TripleRule
import org.emoflon.neo.emsl.util.EMSLUtil

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class EMSLProposalProvider extends AbstractEMSLProposalProvider {
	
	override completeModelRelabelingCommand_OldLabel(
			EObject entity, Assignment assignment, 
  			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if ((entity as RefinementCommand).referencedType.eContainer instanceof Pattern) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(EMSLFlattener.flatten(EcoreUtil.copy((entity as RefinementCommand).referencedType)))) {
				acceptor.accept(createCompletionProposal(nb.name, context))
				for (relation : nb.relations){
					if (relation.name !== null) {
						acceptor.accept(createCompletionProposal(relation.name, context))
					}
				}
			}
		} else {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(EMSLFlattener.flatten(EcoreUtil.copy((entity as RefinementCommand).referencedType)))) {
				acceptor.accept(createCompletionProposal(nb.name, context))
				for (relation : nb.relations){
					if (relation.name !== null) {
						acceptor.accept(createCompletionProposal(relation.name, context))
					}
				}
			}
		}
	}
	
	override completeModelRelationStatement_Target(
			EObject entity, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeModelRelationStatement_Target(entity, assignment, context, acceptor)
		for (nb : collectPossibleTargets(entity as ModelRelationStatement)) {
			acceptor.accept(createCompletionProposal("$" + nb.name, context))
		}
	}
	
	/**
	 * Helper method for collecting possible targets of a ModelRelationStatement.
	 */
	def collectPossibleTargets(ModelRelationStatement entity) {
		var nodes = new HashSet()
		var dispatcher = new EntityAttributeDispatcher()
		for (refinement : dispatcher.getSuperRefinementTypes(entity.eContainer.eContainer as SuperType)) {
			for (nb : dispatcher.getNodeBlocks(EMSLFlattener.flatten(refinement.referencedType))) {
				refinement.relabeling.forEach[rel |
					if (rel.oldLabel.equals(nb.name))
						nb.name = rel.newLabel
				]
				var needed = true
				for (other : dispatcher.getNodeBlocks(entity.eContainer.eContainer as SuperType)) {
					if (nb.name.equals(other.name))
						needed = false
				}
				if (needed && entity.types.map[t | t.type.target].contains(nb.type))
					nodes.add(nb)
			}
		}
		return nodes
	}
	
	override completeModelNodeBlock_Name(
			EObject entity, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		
		super.completeModelNodeBlock_Name(entity, assignment, context, acceptor)
		if (entity instanceof AtomicPattern) {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(EMSLFlattener.flatten(entity))) {
				acceptor.accept(createCompletionProposal(nb.name, context))
			}
		} else {
			for (nb : new EntityAttributeDispatcher().getNodeBlocks(EMSLFlattener.flatten(entity as SuperType))) {
				acceptor.accept(createCompletionProposal(nb.name, context))
			}
		}
	}
	
	override completeImportStatement_Value(
			EObject model, Assignment assignment, 
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var plRes = '''"platform:/resource/'''
		var pPlug = '''"platform:/plugin/'''
		
		// No prefix so ask for beginning of URI first
		if(context.prefix == ""){
			acceptor.accept(createCompletionProposal(plRes, context))
			acceptor.accept(createCompletionProposal(pPlug, context))
			return
		}
		
		// Already a prefix so offer to complete it
		val files = new HashSet<IResource>()
		var root = ResourcesPlugin.workspace.root
		root.accept(new IResourceVisitor() {
			override visit(IResource resource) throws CoreException {
				if (resource.type === IResource.FILE) {
					if (resource.name.contains(".msl"))
						files.add(resource as IFile);
				}
				
				return true;
			}
		})
		
		val filteredFiles = files //
		.map [ f |
			f.fullPath.toString.substring(1)
		].filter [ f |
			!f.contains('''/bin/''')
		].filter [ f |
			!f.contains('''/tgg-gen/''')
		]
		
		// Add neocore
		acceptor.accept(createCompletionProposal('''"«EMSLUtil.ORG_EMOFLON_NEO_CORE_URI»"''', context))
		
		for (f : filteredFiles)
			acceptor.accept(createCompletionProposal(plRes + f + '''"''', context))
	}
	
	override completeCorrespondence_Source(
			EObject model, Assignment assignment, 
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeCorrespondence_Source(model, assignment, context, acceptor)
		var nodes = new HashSet()
		var dispatcher = new EntityAttributeDispatcher()
		var refinements = new HashSet()
		if (model instanceof TripleRule) {
			refinements.addAll(dispatcher.getSuperRefinementTypes(model))
		} else if (model instanceof Correspondence) {
			refinements.addAll(dispatcher.getSuperRefinementTypes(model.eContainer as TripleRule))
		}
		for (refinement : refinements) {
			for (nb : (EMSLFlattener.flatten(refinement.referencedType) as TripleRule).srcNodeBlocks) {
				refinement.relabeling.forEach[rel |
					if (rel.oldLabel.equals(nb.name))
						nb.name = rel.newLabel
				]
				var needed = true
				for (other : (model as TripleRule).srcNodeBlocks) {
					if (nb.name.equals(other.name))
						needed = false
				}
				if (needed)
					nodes.add(nb)
			}
			for (nb : (EMSLFlattener.flatten(refinement.referencedType) as TripleRule).trgNodeBlocks) {
				refinement.relabeling.forEach[rel |
					if (rel.oldLabel.equals(nb.name))
						nb.name = rel.newLabel
				]
				var needed = true
				for (other : (model as TripleRule).trgNodeBlocks) {
					if (nb.name.equals(other.name))
						needed = false
				}
				if (needed)
					nodes.add(nb)
			}
		}
		nodes.forEach[n | acceptor.accept(createCompletionProposal("$" + n.name, context))]				
	}
	
	override completeCorrespondence_Target(
			EObject model, Assignment assignment, 
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeCorrespondence_Target(model, assignment, context, acceptor)
		var nodes = new HashSet()
		var dispatcher = new EntityAttributeDispatcher()
		for (refinement : dispatcher.getSuperRefinementTypes(model.eContainer as SuperType)) {
			for (nb : dispatcher.getNodeBlocks(EMSLFlattener.flatten(refinement.referencedType))) {
				refinement.relabeling.forEach[rel |
					if (rel.oldLabel.equals(nb.name))
						nb.name = rel.newLabel
				]
				var needed = true
				for (other : dispatcher.getNodeBlocks(model.eContainer as SuperType)) {
					if (nb.name.equals(other.name))
						needed = false
				}
				if (needed && nb.type == (model as Correspondence).type.target)
					nodes.add(nb)
			}
		}
		nodes.forEach[n | acceptor.accept(createCompletionProposal("$" + n.name, context))]				
	}
}