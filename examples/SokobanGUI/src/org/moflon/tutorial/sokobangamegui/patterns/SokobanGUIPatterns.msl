import "platform:/resource/SokobanLanguage/src/metamodels/SokobanLanguage.msl"

pattern board {
	board:SokobanLanguage.Board
}

pattern fields {
	board:SokobanLanguage.Board {
		-fields->field
	}
	field:Field
}

pattern occupied {
	field:Field
	fig:Figure {
		-field->field	
	}
}

pattern emptyFields -> fields when forbid occupied

pattern occupiedFields -> fields, occupied {
	fig:Figure {
		-metaType->type
	}
	
	type:EClass
} 

pattern figureTypes {
	figClass:EClass {
		.ename : "Figure"
		-elementOf->mm
	}
	
	eclass:EClass {
		-elementOf->mm
		// TODO: Should be transitive, i.e., -eSuperType(1..*)->
		-eSuperType->figClass
	}
	
	mm:MetaModel {
		.ename : "SokobanLanguage"
	}
}

pattern selectedFigure {
	b:SokobanLanguage.Board {
		-selectedFigure->fig
		-fields->f
	}
	
	fig:Figure {
		-field->f
	}
	
	f:Field
}

pattern oneSokoban { sok:Sokoban }
pattern twoSokobans -> oneSokoban, oneSokoban[sok->otherSok]

constraint oneSokoban = enforce oneSokoban
constraint noTwoSokobans = forbid twoSokobans
constraint exactlyOneSokoban = oneSokoban && noTwoSokobans

pattern endField { 
	endField:Field { 
		.endPos : true
	}
}

constraint oneEndField = enforce endField

pattern block { b:Block }

pattern endFieldBlockedByBoulder -> endField {
	boulder : Boulder {
		-field->endField
	}
}

constraint noBlockedEndField = forbid endFieldBlockedByBoulder

pattern blockNotOnEndFieldInCorner {
	field: Field {
		.endPos : false
		
	}
	fig: Block {
		-field->field
	}

} when noCorner

constraint forbidLeftSide = forbid hasLeft
constraint forbidTopSide = forbid hasTop
constraint forbidRightSide = forbid hasRight
constraint forbidBottomSide = forbid hasBottom

constraint topLeftCorner = forbidLeftSide && forbidTopSide
constraint topRightCorner = forbidRightSide && forbidTopSide
constraint bottomLeftCorner = forbidLeftSide && forbidBottomSide
constraint bottomRightCorner = forbidRightSide && forbidBottomSide

constraint noCorner = topLeftCorner || topRightCorner || bottomLeftCorner || bottomRightCorner
