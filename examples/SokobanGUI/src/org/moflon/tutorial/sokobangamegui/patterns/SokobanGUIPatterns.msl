import "platform:/resource/SokobanLanguage/src/metamodels/SokobanLanguage.msl"

pattern board {
	board:SokobanLanguage.Board
}

pattern fields {
	board:SokobanLanguage.Board {
		-fields->field
	}
	field:Field
}

pattern occupied {
	field:Field
	fig:Figure {
		-field->field	
	}
}

pattern emptyFields -> fields when forbid occupied

pattern occupiedFields -> fields, occupied {
	fig:Figure {
		-metaType->type
	}
	
	type:EClass
} 

pattern figureTypes {
	figClass:EClass {
		.ename : "Figure"
		-elementOf->mm
	}
	
	eclass:EClass {
		-elementOf->mm
		-eSuperType(1..*)->figClass
	}
	
	mm:MetaModel {
		.ename : "SokobanLanguage"
	}
}

pattern selectedFigure {
	b:SokobanLanguage.Board {
		-selectedFigure->fig
		-fields->f
	}
	
	fig:Figure {
		-field->f
	}
	
	f:Field
}

pattern oneSokoban { sok:Sokoban }
pattern twoSokobans -> oneSokoban, oneSokoban[sok->otherSok]

constraint oneSokoban = enforce oneSokoban
constraint noTwoSokobans = forbid twoSokobans
constraint exactlyOneSokoban = oneSokoban && noTwoSokobans

pattern endField { 
	endField:Field { 
		.endPos : true
	}
}

constraint oneEndField = enforce endField

pattern block { b:Block }

pattern endFieldBlockedByBoulder -> endField {
	boulder : Boulder {
		-field-> $endField
	}
}

constraint noBlockedEndField = forbid endFieldBlockedByBoulder

rule deleteFigure -> chooseField {
	-- fig:Figure {
		-- -field->$f
	}
}

abstract rule createFigure -> chooseField {
	++ fig:Figure {
		++ -field-> $f
	}
}

rule createSokoban -> createFigure {
	++ fig:Sokoban
}

rule createBlock -> createFigure {
	++ fig:Block
}

rule createBoulder -> createFigure {
	++ fig:Boulder
}

abstract rule chooseField {
	b:SokobanLanguage.Board {
		-fields->f
	}
	
	f:Field
}

rule setEndField -> chooseField {
	f:Field {
		.endPos := true	
	}
}

rule setNotEndField -> chooseField {
	f:Field {
		.endPos := false
	}
}

rule selectFigure {
	f:Field
	
	newFig:Figure {
		-field->f
	}
	
	fig:Figure
	
	b:SokobanLanguage.Board {
		-fields->f
		-- -selectedFigure->fig
		++ -selectedFigure->newFig
	}
}

// Rules for generating boards

rule createTopLeft {
	++ b:SokobanLanguage.Board {
		++ -fields->f {
			.col := 0
			.row := 0
		}
	}
	
	++ f:Field
}

rule createTopLeftWithAppCond -> createTopLeft when forbid TopLeft

pattern TopLeft {
	otherBoard:SokobanLanguage.Board {
		-fields->otherField {
			.col : 0
			.row : 0
		}
	}
	
	otherField:Field
}

rule createFirstRow {
	b:SokobanLanguage.Board {
		-fields->leftField {
			.row : 0
		}
		
		++ -fields->rightField {
			.row := 0
		}
	}
	
	leftField:Field {
		++ -right->rightField
	}
	
	++ rightField:Field
} when forbid OtherRight

rule createFirstCol {
	b:SokobanLanguage.Board {
		-fields->topField {
			.col : 0
		}
		
		++ -fields->bottomField {
			.col := 0
		}
	}
	
	topField:Field {
		++ -bottom->bottomField
	}
	
	++ bottomField:Field
} when forbid OtherBottom

rule createRestOfFields {
	b:SokobanLanguage.Board {
		-fields->leftField
		-fields->topField
		++ -fields->field
	}
	
	leftField:Field {
		++ -right->field
	}
	
	topField:Field {
		++ -bottom->field
	}
	
	++ field:Field
} when noBottomAndNoRight

constraint NoOtherBottom = forbid OtherBottom
constraint NoOtherRight = forbid OtherRight
constraint noBottomAndNoRight = NoOtherBottom && NoOtherRight

pattern OtherBottom {
	topField:Field {
		-bottom->otherField
	}
	
	otherField:Field
}

pattern OtherRight {
	leftField:Field {
		-right->otherField
	}
	
	otherField:Field
}