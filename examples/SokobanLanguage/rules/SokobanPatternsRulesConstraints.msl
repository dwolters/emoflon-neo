import "platform:/resource/SokobanLanguage/metamodels/SokobanLanguage.msl"

// BoardPattern.gt

pattern oneSokoban {
	sokoban : Sokoban
}

pattern oneBlock {
	block : Block
}

pattern oneEndField {
	field : Field {
		.endPos == true
	}
}

pattern anOccupiedField {
	
	field : Field {
		-figure-> fig
	}
	
	fig : Figure	
}

pattern anOccupiedSokobanField {
	
	field : Field {
		-figure-> fig
	}
	
	fig : Sokoban	
}
pattern anOccupiedBlockField {
	
	field : Field {
		-figure-> fig
	}
	
	fig : Block	
}
pattern anOccupiedBoulderField {
	
	field : Field {
		-figure-> fig
	}
	
	fig : Boulder	
}


pattern allFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
		}
	}
	field : Field
}

pattern allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
		}
		-fields -> fieldL {
			.row : 1
		}
		-fields -> fieldR {
			.row : 1
		}
	}
	field : Field {
		-right -> fieldR
	}
	
	fieldL : Field {
		-right -> field
	}
	
	fieldR : Field {
	}
}

pattern allNotBorderFieldsInARowAndCol -> allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
			.col : 2
		}
		-fields -> fieldL {
			.row : 1
			.col : 1
		}
		-fields -> fieldR {
			.row : 1
			.col : 3
		}
	}
}

pattern allNotBorderFieldsInDiffRows -> allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 4
			.col : 2
		}
	}
}

pattern all3x3Fields {
	b: SokobanLanguage.Board {
		-fields -> field11
		-fields -> field12
		-fields -> field13
		-fields -> field21
		-fields -> field22
		-fields -> field23
		-fields -> field31
		-fields -> field32
		-fields -> field33
	}
	field11 : Field {
		-right -> field12
		-bottom -> field21
	}
	field12 : Field {
		-right -> field13
		-bottom -> field22
	}
	field13 : Field {
		-bottom -> field23
	}
	field21 : Field {
		-right -> field22
		-bottom -> field31
	}
	field22 : Field {
		-right -> field23
		-bottom -> field32
	}
	field23 : Field {
		-bottom -> field33
	}
	field31 : Field {
		-right -> field32
	}
	field32 : Field {
		-right -> field33
	}
	field33 : Field 
}


pattern boulderOnEndField -> oneEndField, anOccupiedField {
	fig : Boulder
} when forbid block

pattern block {
	fig: Block
}

pattern blockNotOnEndFieldInCorner -> anOccupiedField {
	field: Field {
		.endPos == false
	}
	fig: Block
} when forbid hasLeft && forbid hasTop || forbid hasRight && forbid hasTop 
	|| forbid hasLeft && forbid hasBottom || forbid hasRight && forbid hasBottom


pattern hasLeft {
	field: Field {
		-left->leftFig
	}
	leftFig: Field
}

pattern hasTop {
	field: Field {
		-top->topFig
	}
	topFig: Field
}

pattern hasRight {
	field: Field {
		-right->rightFig
	}
	rightFig: Field
}

pattern hasBottom {
	field: Field {
		-bottom->bottomFig
	}
	bottomFig: Field
}


// RulesForMovingSokoban.gt

pattern occupiedField {
	fig : Figure
	to : Field {
		-figure-> fig
	}
}

pattern occupiedNext -> occupiedField {} //[fig -> fig, to -> next] { }

abstract rule moveSokoban {
	from : Field
	
	to : Field
	
	sok : Sokoban {
		-- -field-> from
		++ -field-> to
	}
}

abstract rule pushBlock {
	to : Field
	
	next : Field
	
	block : Block {
		-- -field-> to
		++ -field-> next
	}
}


rule moveSokobanUp -> moveSokoban {
	from : Field {
		-top->from
	}
} when forbid occupiedField

rule pushBlockUp -> pushBlock, moveSokobanUp {
	to : Field {
		-top-> next
	}
} when forbid occupiedNext

rule moveSokobanDown -> moveSokoban, pushBlock {
	from : Field {
		-bottom-> next
	}
} when forbid occupiedNext

rule pushBlockDown -> pushBlock, moveSokobanDown {
	to : Field {
		-bottom-> next
	}
} when forbid occupiedNext
	






