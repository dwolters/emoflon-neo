import "platform:/resource/SokobanLanguage/metamodels/SokobanLanguage.msl"

// BoardPattern.gt

pattern oneSokoban {
	sokoban : Sokoban
}

pattern oneBlock {
	block : Block
}

pattern oneEndField {
	field : Field {
		.endPos == true
	}
}

pattern anOccupiedField {
	fig : Figure
	
	field : Field {
		-figure-> fig
	}
}

pattern boulderOnEndField -> oneEndField, anOccupiedField {
	fig : Boulder
} when forbid block

pattern block {
	fig: Block
}

pattern blockNotOnEndFieldInCorner -> anOccupiedField {
	field: Field {
		.endPos == false
	}
	fig: Block
} when forbid hasLeft && forbid hasTop || forbid hasRight && forbid hasTop 
	|| forbid hasLeft && forbid hasBottom || forbid hasRight && forbid hasBottom


pattern hasLeft {
	field: Field {
		-left->leftFig
	}
	leftFig: Field
}

pattern hasTop {
	field: Field {
		-top->topFig
	}
	topFig: Field
}

pattern hasRight {
	field: Field {
		-right->rightFig
	}
	rightFig: Field
}

pattern hasBottom {
	field: Field {
		-bottom->bottomFig
	}
	bottomFig: Field
}


// RulesForMovingSokoban.gt

pattern occupiedField {
	fig : Figure
	to : Field {
		-figure-> fig
	}
}

pattern occupiedNext -> occupiedField {} //[fig -> fig, to -> next] { }

abstract rule moveSokoban {
	from : Field
	
	to : Field
	
	sok : Sokoban {
		-- -field-> from
		++ -field-> to
	}
}

abstract rule pushBlock {
	to : Field
	
	next : Field
	
	block : Block {
		-- -field-> to
		++ -field-> next
	}
}


rule moveSokobanUp -> moveSokoban {
	from : Field {
		-top-> pushBlock.next
	}
} when forbid occupiedField

rule pushBlockUp -> pushBlock, moveSokobanUp {
	to : Field {
		-top-> pushBlock.next
	}
} when forbid occupiedNext

rule moveSokobanDown -> moveSokoban, pushBlock {
	from : Field {
		-bottom-> pushBlock.next
	}
} when forbid occupiedNext

rule pushBlockDown -> pushBlock, moveSokobanDown {
	to : Field {
		-bottom-> pushBlock.next
	}
} when forbid occupiedNext
	






