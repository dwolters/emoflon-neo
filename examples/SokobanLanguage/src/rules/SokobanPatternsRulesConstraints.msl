import "platform:/resource/SokobanLanguage/src/metamodels/SokobanLanguage.msl"

// BoardPattern.gt

pattern oneSokoban {
	sokoban : Sokoban
}
pattern twoSokoban {
	sokoban: Sokoban
	sokoban2: Sokoban
}

pattern oneSokobanSelectedFigureRequired {
	sokoban : Sokoban
} when enforce selectedFigureRequired

constraint noSokoban = forbid oneSokoban
constraint oneSokobans = enforce oneSokoban
constraint twoSokobans = enforce twoSokoban

constraint hasOneSokoban = oneSokobans && !twoSokobans

pattern sokobanMustBeSelectedFigure {
	sokoban:Sokoban
} 

constraint sokobanIsSelectedFigure = if oneSokoban then selectedFigureRequired
constraint sokokanIsNotSelectedFigure = !sokobanIsSelectedFigure
constraint sokobanIfNotSelectedThenSeleceted = sokokanIsNotSelectedFigure || sokobanIsSelectedFigure

pattern selectedFigureRequired {
	b:SokobanLanguage.Board {
		-selectedFigure->sokoban
	}
	sokoban:Sokoban
}

pattern oneBlock {
	block : Block
}

pattern oneEndField {
	field : Field {
		.endPos : true
	}
}

pattern anSelectedFigure {
	
}

pattern anOccupiedField {
	
	field : Field
	
	fig : Figure {
		-field-> field
	}
}

pattern anOccupiedSokobanField {
	
	field : Field
	
	fig : Sokoban {
		-field-> field
	}
}

pattern anOccupiedBlockField {	
	field : Field
	
	fig : Block	{
		-field-> field
	}
}

pattern anOccupiedBoulderField {
	
	field : Field
	
	fig : Boulder {
		-field-> field
	}	
}

pattern byBlockAndBoulderOccupiedFields -> anOccupiedBlockField, 
	anOccupiedBoulderField [field -> otherField,fig -> otherFig]

pattern allFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
		}
	}
	field : Field
}

pattern allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
		}
		-fields -> fieldL {
			.row : 1
		}
		-fields -> fieldR {
			.row : 1
		}
	}
	field : Field {
		-right -> fieldR
	}
	
	fieldL : Field {
		-right -> field
	}
	
	fieldR : Field {
	}
}

pattern allNotBorderFieldsInARowAndCol -> allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field{
			.row : 1
			.col : 2
		}
		-fields -> fieldL {
			.row : 1
			.col : 1
		}
		-fields -> fieldR {
			.row : 1
			.col : 3
		}
	}
}

pattern allNotBorderFieldsInDiffRows -> allNotBorderFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 4
			.col : 2
		}
	}
}

pattern all3x3Fields {
	b: SokobanLanguage.Board {
		-fields -> field11
		-fields -> field12
		-fields -> field13
		-fields -> field21
		-fields -> field22
		-fields -> field23
		-fields -> field31
		-fields -> field32
		-fields -> field33
	}
	field11 : Field {
		-right -> field12
		-bottom -> field21
	}
	field12 : Field {
		-right -> field13
		-bottom -> field22
	}
	field13 : Field {
		-bottom -> field23
	}
	field21 : Field {
		-right -> field22
		-bottom -> field31
	}
	field22 : Field {
		-right -> field23
		-bottom -> field32
	}
	field23 : Field {
		-bottom -> field33
	}
	field31 : Field {
		-right -> field32
	}
	field32 : Field {
		-right -> field33
	}
	field33 : Field 
}

pattern all2x2Fields {
	b: SokobanLanguage.Board {
		-fields -> field11
		-fields -> field12
		-fields -> field21
		-fields -> field22
	}
	
	field11 : Field {
		-right -> field12
		-bottom -> field21
	}
	
	field12 : Field {
		-bottom -> field22
	}
	
	field21 : Field {
		-right -> field22
	}
	
	field22 : Field
}

pattern boulderOnEndField -> oneEndField, anOccupiedField {
	fig : Boulder
} when forbid block

pattern block {
	fig: Block
}

pattern blockNotOnEndFieldInCorner -> anOccupiedField {
	field: Field {
		.endPos : false
		
	}
	fig: Block {
		-field->field
	}

} when noCorner

constraint forbidLeftSide = forbid hasLeft
constraint forbidTopSide = forbid hasTop
constraint forbidRightSide = forbid hasRight
constraint forbidBottomSide = forbid hasBottom

constraint topLeftCorner = forbidLeftSide && forbidTopSide
constraint topRightCorner = forbidRightSide && forbidTopSide
constraint bottomLeftCorner = forbidLeftSide && forbidBottomSide
constraint bottomRightCorner = forbidRightSide && forbidBottomSide

constraint noCorner = topLeftCorner || topRightCorner || bottomLeftCorner || bottomRightCorner

constraint extremeConstraint = ((!topLeftCorner && topRightCorner) || !topRightCorner) && !bottomLeftCorner && (bottomRightCorner || (!bottomLeftCorner || (!topRightCorner && !topRightCorner)))

pattern hasLeft {
	field: Field
	
	leftField: Field {
		-right-> field
	}
}

pattern hasTop {
	field: Field
	
	topField: Field {
		-bottom-> field
	}
}

pattern hasRight {
	field: Field {
		-right->rightField
	}
	rightField: Field
}

pattern hasBottom {
	field: Field {
		-bottom->bottomField
	}
	bottomField: Field
}


// RulesForMovingSokoban.gt

pattern occupiedField {
	fig : Figure {
		-field-> to
	}
	to : Field
}

pattern occupiedNext -> occupiedField [to -> next] { }

abstract rule moveSokoban {
	from : Field
	
	to : Field
	
	sok : Sokoban {
		-- -field-> from
		++ -field-> to
	}
} when forbid occupiedField

abstract rule pushBlock {
	to : Field
	
	next : Field
	
	block : Block {
		-- -field-> to
		++ -field-> next
	}
}


rule moveSokobanUp -> moveSokoban {
	to : Field {
		-bottom-> from
	}
} when forbid occupiedField

rule pushBlockUp -> pushBlock, moveSokobanUp {
	from : Field {
		-bottom-> next
	}
} when forbid occupiedNext

rule moveSokobanDown -> moveSokoban, pushBlock {
	from : Field {
		-bottom-> next
	}
} when forbid occupiedNext

rule pushBlockDown -> pushBlock, moveSokobanDown {
	to : Field {
		-bottom-> next
	}
} when forbid occupiedNext
	
	
pattern oneField {
	f:Field
} when hasBottomAndRightField

pattern oneFieldNeg {
	f:Field
} when !hasBottomAndRightField

pattern oneFieldEnforceTwo {
	f:Field
} when enforce oneTwoField

pattern oneFieldForbidTwo {
	f:Field
} when forbid oneTwoField

pattern oneFieldIfThenTwo {
	f:Field
} when if twoField then oneTwoField


pattern twoField {
	f:Field
	f2:Field
}
pattern oneTwoField {
	f:Field {
		-bottom -> f2
	}
	f2:Field
}

pattern oneFieldHasBottomAndRight {
	f:Field
} when hasBottomAndRightField
pattern oneFieldHasNoBottomAndNoRight {
	f:Field
} when !hasBottomAndRightField

pattern oneFieldHasBottomAndNoRight {
	f:Field
} when hasBottomAndNoRightField


pattern neighborRightField {
	f:Field {
		-right -> f2
	}
	f2:Field
}
pattern neighborBottomField {
	f:Field {
		-bottom -> f2
	}
	f2:Field
}
pattern neighborRightField2 {
	f:Field {
		-right -> f3
	}
	f3:Field
}
constraint hasRightField = enforce neighborRightField
constraint hasBottomField = enforce neighborBottomField
constraint hasBottomAndRightField = hasBottomField && hasRightField
constraint hasBottomAndNoRightField = hasBottomField && !hasRightField

constraint twoConnFields = enforce neighborBottomField
constraint iftwothenConn = if twoField then neighborBottomField
constraint ifBottomThenRight = if neighborBottomField then neighborRightField2

constraint hasRightIfThen = if neighborRightField then neighborBottomField
constraint hasBottomAndRighFieldIfThen = hasRightIfThen