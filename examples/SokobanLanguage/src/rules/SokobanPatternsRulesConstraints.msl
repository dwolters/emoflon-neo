import "platform:/resource/SokobanLanguage/src/metamodels/SokobanLanguage.msl"

// BoardPattern.gt

pattern sokobanOnFieldOfBoard {
	
	b:SokobanLanguage.Board {
		-selectedFigure->sokoban
		-fields->f1 {
			.col: 0
			.row: 0
		}
		-fields->f2 {
			.col: 1
			.row: 0
		}
	}
	f1:Field {
		-right->f2
		.endPos: false
	}
	f2:Field {
		.endPos: false
	}
	sokoban:Sokoban {
		-field->f1
	}
	
}

pattern blockOnEndField {
    b:Block {
        -field->f
    }
    f:Field {
        .endPos:true
    }
}
pattern blockOnNoEndField {
    b:Block {
        -field->f
    }
    f:Field {
        .endPos:false
    }
}

constraint enforceBlockOnEndField = enforce blockOnEndField
constraint enforceBlockOnNoEndField = enforce blockOnNoEndField
constraint forbidBlockOnNoEndField = forbid blockOnNoEndField

constraint gameFinished = forbidBlockOnNoEndField || (enforceBlockOnNoEndField && enforceBlockOnEndField)

pattern oneSokoban {
	sokoban : Sokoban
}

pattern twoSokoban {
	sokoban: Sokoban
	sokoban2: Sokoban
}
 
pattern oneSokobanSelectedFigureRequired {
	sokoban : Sokoban
} when enforce selectedFigureRequired

constraint noSokoban = forbid oneSokoban
constraint oneSokobans = enforce oneSokoban
constraint twoSokobans = enforce twoSokoban

constraint hasOneSokoban = oneSokobans && !twoSokobans

constraint sokobanIsSelectedFigure = if oneSokoban then selectedFigureRequired

pattern selectedFigureRequired {
	b:SokobanLanguage.Board {
		-selectedFigure->sokoban
	}
	sokoban:Sokoban
}

pattern oneBlock {
	block : Block
}

pattern oneEndField {
	field : Field {
		.endPos : true
	}
}

pattern anOccupiedField {
	field : Field
	
	fig : Figure {
		-field-> field
	}
}

pattern anOccupiedSokobanField {
	field : Field
	
	fig : Sokoban {
		-field-> field
	}
}

pattern anOccupiedBlockField {	
	field : Field
	
	fig : Block	{
		-field-> field
	}
}

pattern anOccupiedBoulderField {
	field : Field
	
	fig : Boulder {
		-field-> field
	}	
}

pattern byBlockAndBoulderOccupiedFields -> anOccupiedBlockField, 
	anOccupiedBoulderField [field -> otherField,fig -> otherFig]

pattern allFieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field {
			.row : 1
		}
	}
	field : Field
}

abstract pattern fieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> field 
		-fields -> fieldL 
		-fields -> fieldR 
	}
	field : Field {
		-right -> fieldR
	}
	
	fieldL : Field {
		-right -> field
	}
	
	fieldR : Field
}

pattern allNotBorderFieldsInARow -> fieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> $field {
			.row : 1
		}
		-fields -> $fieldL {
			.row : 1
		}
		-fields -> $fieldR {
			.row : 1
		}
	}
}

pattern allNotBorderFieldsInARowAndCol -> fieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> $field {
			.row : 1
			.col : 2
		}
		-fields -> $fieldL {
			.row : 1
			.col : 1
		}
		-fields -> $fieldR {
			.row : 1
			.col : 3
		}
	}
}

pattern allNotBorderFieldsInDiffRows -> fieldsInARow {
	b : SokobanLanguage.Board {
		-fields -> $field {
			.row : 4
			.col : 2
		}
		-fields -> $fieldL {
			.row : 1
		}
		-fields -> $fieldR {
			.row : 1
		}
	}
}

pattern all3x3Fields {
	b: SokobanLanguage.Board {
		-fields -> field11
		-fields -> field12
		-fields -> field13
		-fields -> field21
		-fields -> field22
		-fields -> field23
		-fields -> field31
		-fields -> field32
		-fields -> field33
	}
	field11 : Field {
		-right -> field12
		-bottom -> field21
	}
	field12 : Field {
		-right -> field13
		-bottom -> field22
	}
	field13 : Field {
		-bottom -> field23
	}
	field21 : Field {
		-right -> field22
		-bottom -> field31
	}
	field22 : Field {
		-right -> field23
		-bottom -> field32
	}
	field23 : Field {
		-bottom -> field33
	}
	field31 : Field {
		-right -> field32
	}
	field32 : Field {
		-right -> field33
	}
	field33 : Field 
}

pattern all2x2Fields {
	b: SokobanLanguage.Board {
		-fields -> field11
		-fields -> field12
		-fields -> field21
		-fields -> field22
	}
	
	field11 : Field {
		-right -> field12
		-bottom -> field21
	}
	
	field12 : Field {
		-bottom -> field22
	}
	
	field21 : Field {
		-right -> field22
	}
	
	field22 : Field
}

pattern boulderOnEndField -> oneEndField, anOccupiedField {
	fig : Boulder
} when forbid block

pattern block {
	fig: Block
}

pattern blockNotOnEndFieldInCorner -> anOccupiedField {
	field: Field {
		.endPos : false
		
	}
	fig: Block {
		-field->field
	}

} when noCorner

pattern blockOnFieldCond {
	field: Field {
		.endPos : false
	}
	fig: Block {
		-field->field
	}
} when hasLeftNeighbor

constraint forbidLeftSide = forbid hasLeft
constraint forbidTopSide = forbid hasTop
constraint forbidRightSide = forbid hasRight
constraint forbidBottomSide = forbid hasBottom

constraint enforceHasLeft = enforce hasLeft
constraint forbidHasTop = forbid hasTop
constraint hasLeftNeighbor = enforceHasLeft || (!enforceHasLeft && forbidHasTop)

constraint topLeftCorner = forbidLeftSide && forbidTopSide
constraint topRightCorner = forbidRightSide && forbidTopSide
constraint bottomLeftCorner = forbidLeftSide && forbidBottomSide
constraint bottomRightCorner = forbidRightSide && forbidBottomSide

constraint noCorner = topLeftCorner || topRightCorner || bottomLeftCorner || bottomRightCorner

constraint extremeConstraint = ((!topLeftCorner && topRightCorner) || !topRightCorner) && !bottomLeftCorner && (bottomRightCorner || (!bottomLeftCorner || (!topRightCorner && !topRightCorner)))

pattern hasLeft {
	field: Field
	
	leftField: Field {
		-right-> field
	}
}

pattern hasTop {
	field: Field
	
	topField: Field {
		-bottom-> field
	}
}

pattern hasRight {
	field: Field {
		-right->rightField
	}
	rightField: Field
}

pattern hasBottom {
	field: Field {
		-bottom->bottomField
	}
	bottomField: Field
}


// RulesForMovingSokoban.gt

pattern occupiedField {
	fig : Figure {
		-field-> to
	}
	to : Field
}

pattern occupiedNext -> occupiedField [to -> next] { }

abstract rule moveSokoban {
	from : Field
	
	to : Field
	
	sok : Sokoban {
		-- -field-> from
		++ -field-> to
	}
	
	b:SokobanLanguage.Board {
		-fields->to
	}
}

abstract rule pushBlock {
	to : Field
	
	next : Field
	
	block : Block {
		-- -field-> to
		++ -field-> next
	}
}

rule moveSokobanUp -> moveSokoban {
	to : Field {
		-bottom-> $from
	}
}

rule moveSokobanUpWithCondition -> moveSokobanUp
	when forbid occupiedField

rule pushBlockUp -> pushBlock, moveSokobanUp {
	next : Field {
		-bottom-> to 
	}
	to : Field {
		-bottom-> $from
	}
} when forbid occupiedNext

rule moveSokobanDown -> moveSokoban {
	from : Field {
		-bottom-> $to
	}
}

rule moveSokobanDownWithCondition -> moveSokobanDown
	when forbid occupiedField

rule pushBlockDown -> pushBlock, moveSokobanDown {
	to : Field {
		-bottom-> $next
	}
} when forbid occupiedNext

pattern oneField {
	f:Field
} when hasBottomAndRightField

pattern oneFieldNeg {
	f:Field
} when !hasBottomAndRightField

pattern oneFieldEnforceTwo {
	f:Field
} when enforce oneTwoField

pattern oneFieldForbidTwo {
	f:Field
} when forbid oneTwoField

pattern twoField {
	f:Field
	f2:Field
}

pattern fourField {
	f1:Field
	f2:Field
	f3:Field
	f4:Field
}
pattern oneTwoField {
	f:Field {
		-bottom -> f2
	}
	f2:Field
}

pattern oneFieldHasBottomAndRight {
	f:Field
} when hasBottomAndRightField
pattern oneFieldHasNoBottomOrNoRight {
	f:Field
} when !hasBottomAndRightField

pattern oneFieldHasBottomAndNoRight {
	f:Field
} when hasBottomAndNoRightField


pattern neighborRightField {
	f:Field {
		-right -> f2
	}
	f2:Field
}
pattern neighborBottomField {
	f:Field {
		-bottom -> f2
	}
	f2:Field
}
pattern neighborRightField2 {
	f:Field {
		-right -> f3
	}
	f3:Field
}
constraint hasRightField = enforce neighborRightField
constraint hasBottomField = enforce neighborBottomField
constraint hasBottomAndRightField = hasBottomField && hasRightField
constraint hasBottomAndNoRightField = hasBottomField && !hasRightField

constraint twoConnFields = enforce neighborBottomField
constraint ifTwoThenConn = if twoField then neighborBottomField
constraint ifBottomThenRight = if neighborBottomField then neighborRightField2

constraint hasRightIfThen = if neighborRightField then neighborBottomField

pattern sokOnField {
	sok:Sokoban {
		-field -> f
	}
	f: Field
}
pattern blockOnField {
	b:Block {
		-field-> f
	}
	f:Field
}
constraint sokOnFieldThenBlockOnField = if sokOnField then blockOnField
